<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="学习，生活，思考，代码，博客" />
   
  <meta name="description" content="梦想的萌生岛" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    RD指南 |  梦想岛
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

<link rel="alternate" href="/atom.xml" title="梦想岛" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      <section class="outer">
  <article id="post-《程序员面试经典》" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  RD指南
</h1>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/04/28/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E3%80%8B/" class="article-date">
  <time datetime="2020-04-28T02:38:40.000Z" itemprop="datePublished">2020-04-28</time>
</a>
      
      
      
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">8.1k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">34 分钟</span>
        </span>
    </span>
</div>

      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h2 id="行为面试题"><a href="#行为面试题" class="headerlink" title="行为面试题"></a>行为面试题</h2><p>问：<br>Tell us about yourself. 谈谈你自己</p>
<p>Why should we hire you? 我们为什么要雇佣你</p>
<p>Why did you leave your last job? 你为什么离职</p>
<p>Tell me about your scholastic record 谈谈你在学校的表现</p>
<p>Tell  me about your extra-curricular activities and interests谈谈你的课余活动和爱好</p>
<p>How would your last boss describe you. 你的前老板是怎么评价你的？</p>
<p>What salary are you expecting? 你期待得到怎样的薪资待遇</p>
<p>What is your greatest weakness?你认为自己最大的弱点是什么</p>
<p>How would your friends or coleagues describe you? 你的朋友或者同事会怎样评价你</p>
<p>Give me summary of your cureent job description. 简单描述一下你现在的工作</p>
<p>How do you rate yourself as a professional?作为专业人员，你如何评价你自己</p>
<p>What make you think you would be a success in this position?<br>是什么让你认为自己能胜任这份工作？</p>
<p>What contribution did you make to your current(previous) organization<br>你对之前的单位有何贡献</p>
<p>What traits do you admire?<br>你欣赏哪种性格的人</p>
<p>What provide you with a sense of accomplishment?</p>
<a id="more"></a>



<h2 id="避免误区"><a href="#避免误区" class="headerlink" title="避免误区"></a>避免误区</h2><p>误区1：只在计算机上练习<br>误区2：不做行为面试题演练，很多面试者只做了技术面试题，而面试官很可能两者都考察，行为面试题<br>准备工作比较轻松，用心回顾你以往的项目和经历，然后准备一些小故事.<br>误区3：不作模拟面试训练，找朋友作为面试官模拟面试<br>误区4：试图死记硬背答案，最靠谱的是不看答案，先把书里的题认真做一边，这样才有可能练就各种技能和技巧，<br>从容应对新问题。这样就算你最后复习一下为数不多的题，这种做法也会对你很有帮助。质量胜于数量。<br>误区5：不大声说出你的解题思路<br>你心里想什么面试不可能用显微镜掏出来，因此你沉默太久，他会认为你毫无进展。你得多出声，没准说着说真就<br>找到了解法。请大声说出你解题的思路，这样他就知道你还在处理这个问题，没有卡壳，最大的作用是<br>显现你的沟通能力。<br>误区6：过于仓促<br>写程序不是竞赛，面试也不是。所以解题时不要太过仓促。请放慢节奏多做测试。问题考虑周全些。<br>误区7：代码不够严谨<br>写代码时，不妨设想一下你在处理实际问题，将代码分成不同的子程序，并精心设计数据结构来处理相应的数据<br>误区8：不做测试<br>写完代码后，要“运行”（或审查）一下程序来验证结果。或者，在处理复杂问题时，你还可以边写代码边测试<br>误区9：修正错误漫不经心<br>发现BUG，要三思而行，修正前先确定出原因。有bug正常，但胡乱修改代码却很严重。<br>误区10：轻言放弃<br>遇到棘手的问题不要轻言放弃！  </p>
<p><strong>1.实地训练是这样子：</strong><br>白板测试，准备纸和笔，先写好全部代码人工测试后再进行计算机编译测试。  </p>
<p>必要经验–面试之前<br>必要准备：<br>-“你为什么要加入微软”<br>–“自打接触计算机以来，我就一直用微软的软件，贵公司开发的软件产品令人赞不绝口。比如，我最近一直在Visual Studio开发环境中学习游戏编程，它的API实在是太好用了”。  </p>
<p>多承担一些编程职责：<br>在不透露跳槽意向的前提下，你可以向经理表达自己想在编程上接受更大的挑战。尽可能多地参与一些重大项目，并多多使用对自己以后有利的技术，将来它们会成为简历的亮点。<br>善用晚上和周末的闲暇时光：<br>如果有时间可以试着构建一些手机应用、网页应用或桌面软件。这些项目经验可以写在上面，没有什么比“为兴趣而工作”更能打动人的啦。<br>公司青睐的人才是：一是天资聪明，二是有扎实的编程功底。  </p>
<h2 id="数组与字符串"><a href="#数组与字符串" class="headerlink" title="数组与字符串  "></a><strong>数组与字符串</strong>  </h2><p><strong>1.散列表</strong><br>散列表是一种将键映射为值从而实现快速查找的数据结构。散列表包含一个底层数组和一个散列函数。插入一个对象以及的键时，散列函数会将键映射为数组的一个索引。然后，这个对象就会存储到数组中该索引对应的位置。<br>除了创建按索引hash(key)储存对象的超大数组，我们可以选用小得多的数组，并将对象储存在索引为hash(key)%array_length的数组元素指向的链表中。要通过某个键来查找对象，就必须根据散列表找到对应的链表，然后在链表中查找相应的键。<br>我们采用二叉树来实现散列表。只要我们让这棵树保持平衡，就能保证数据查找用时为O(log n)。此外，这种实现占用的空间可能更少，原因很简单，我们不必一开始就分配很大的数组。  </p>
<p>散列表的简答Java实现  </p>
<pre><code>public HashMap&lt;Integer, Student&gt; buildMap(Student[] student){
    HashMap&lt;Integer, Student&gt; map = new HashMap&lt;Integer, Student&gt;();
    for(Student s : students) map.put(s.getId(), s);
    return map;
}</code></pre><p><a href="https://www.cnblogs.com/luanyichao/p/8033848.html" target="_blank" rel="noopener">Java必须知道的常用类</a></p>
<p><strong>2.ArrayList(动态数组)</strong><br>ArrayList,即动态数组，是一种按需动态调整大小的数组，数据访问时间是O(1).  </p>
<pre><code>public ArrayList&lt;String&gt; merge(String[] words, String[] more){
    ArrayList&lt;String&gt; sentence = new ArrayList&lt;String&gt;();
    for(String w : words) sentence.add(w);
    for(String w : more)  sentence.add(w);
    return sentence;
}</code></pre><p><strong>3.StringBuffer</strong>   </p>
<p>多个字符拼接方法：  </p>
<pre><code>public String joinWords(String[] words){
    String sentence = &quot;&quot;;
    for(String w : words){
        sentence = sentence + w;
    }
    return sentence;
}  </code></pre><p>StringBuffer会直接创建一个足以容纳所有字符串的数组，等到拼接完成才将这些字符串转成一个字符串。  </p>
<pre><code>public String joinWords(String[] words)
{
    StringBuffer sentence = new StringBuffer();
    for(String w : word){
        sentence.append(w);
    }
    return sentence.toString();
}</code></pre><h2 id="算法与程序设计"><a href="#算法与程序设计" class="headerlink" title="算法与程序设计"></a>算法与程序设计</h2><h2 id="问题总结1-1-确定一个字符串所有字符是否全都不同"><a href="#问题总结1-1-确定一个字符串所有字符是否全都不同" class="headerlink" title="问题总结1-1-确定一个字符串所有字符是否全都不同  "></a><strong>问题总结1-1-确定一个字符串所有字符是否全都不同</strong>  </h2><p><strong>1.1 实现一个算法，确定一个字符串所有字符是否全都不同。假设不允许使用额外的数据结构，又该如何处理</strong>。  </p>
<p>方法一步骤：  </p>
<pre><code>1.问问面试官字符串是用什么编码？  
    ASCII：可以编码256个字符（00--FF）  
    Unicode:可以编码65536个字符（0000-FFFF）  
    假如是ASCII；  
2首先判断一下长度如果一个字符长度超过指定的长度  
3.然后创建一个256容量的数组  
4.判断对应字母位置的数组内容是否为true  
5.为true,就重复，没有就在该指定位置置true  </code></pre><hr>
<pre><code>public class Unique{
    public static  boolean Unique2Chars(String str){
        if(str.length() &gt; 256){
            return false;
        }
        boolean char_set[] = new boolean[256];
        for(int i=0; i&lt;str.length(); i++){
            int val = str.charAt(i);
            if(char_set[val]){
                return false;
            }
            char_set[val]=true;
        }
        return true;
    }
    public static void main(String[] args){
        String test=&quot;abcdefg&quot;;
        String test1=&quot;abdeff&quot;;
        boolean flag1=Unique2Chars(test);
        boolean flag2=Unique2Chars(test1);
        System.out.println(flag1);
        System.out.println(flag2);
    }
}  </code></pre><p>这个代码复杂度为O（n），其中n为字符串长度。空间复杂度为O（1）  </p>
<p>方法二：  </p>
<p>使用位向量，可以将空间减少为原来的1/8,下面的代码假定字符串只含有小写字母a-z。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 1.判断长度是否没有超过256个字母</span><br><span class="line">* 2.初始化一个变量CHECK为0；</span><br><span class="line">* 3.遍历字符串每个字母，获取对应ASCII值并判断CHECK位已经被置位了吗，置位了就是出错；</span><br><span class="line">* 4.没有置位就对字母对应的ACCISS值进行CHECK置位</span><br></pre></td></tr></table></figure>

<pre><code>public boolean isUniqueChars(String str)
{
    if(str.length() &gt; 256) return false;
    int check=0;
    for(int i=0 ; i&lt;str.length(); i++){
        int val = str.charAt(i);
        if((check &amp; (1&lt;&lt;val))&gt;0){
            return false;
        }
        checker |= (1&lt;&lt;val);
    }
    return true;
}</code></pre><p>问题总结 1-2-反转一个null结尾的字符串</p>
<p>用C或C++实现void reverse(char* str)函数，即反转一个null结尾的字符串<br>你可能会忽略：不分配额外空间，直接就地反转字符串，另外还要注意null字符。<br>C语言版：<br>void reverse（char  <em>str）{<br>    char</em>  end = str;<br>    char tmp;<br>    if(str){<br>        while(*end){<br>            ++end;          //找出字符串末尾<br>        }<br>        –end;  //回退一个字符，最后一个位null字符</p>
<pre><code>//从字符串首尾开始交换两个字符
//直至两个指针在中间碰头
while(str&lt;end){
    tmp=*str;
    *str++ = *end;
    *end-- = tmp;
}
 }</code></pre><p>}</p>
<p>问题总结 1-3-一个字符串的字符重新排列后，能否变成另一个字符串   </p>
<p>给定两个字符串，请编写程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串？<br>需要询问面试官是否区分大小写。还要清楚是否考虑空白字符<br>—–这里是假定变位词区分大小写，也要考虑空白符。<br>比较两个字符串时，只要两个长度不同，就不可能是变位词。<br>方法1.排序字符串<br>若两个字符串互为变位词，那么它们拥有同一组字符，只不过顺序不同。因此，对字符串排序，组成这两个变位词的字符就会有相同的顺序。我们只需要比较排序后的字符串。  </p>
<pre><code>public String sort(String s){
    char[] content = s.toCharArray();
    java.util.Arrays.sort(content);
    return new String(content);
}
public boolean permutation(String s, String t){
    if(s.length() != t.length()){
        return false;
    }
    return sort(s).equals(sort(t));
}</code></pre><p><strong>方法二：检查两个字符串的各字符数是否相同</strong><br>我们只需遍历字母表，计算每个字符出现的次数  </p>
<pre><code>public boolean permutation(String s , String t){
    if(s.length() != t.lenght()){
        return false;
    }
    int[] letters = new int[256];  //假设条件
    char[] s_array = s.toCharArray();
    for(char c : s_arra){
        letters[c]++;
    }
    for(int i=0; i&lt;t.length(); i++){
        int c= (int ) t.charAt(i);
        if(--letters[c] &lt; 0){
            return false;
        }
    }
    return true;
}</code></pre><p>———–这里最好跟面试官核实一下字符集的大小，这里假设的字符集是ASCII——–</p>
<p><strong>问题总结1-4-字符串空格替换为“%20”</strong>  </p>
<p>编写一个方法，将字符串中的空格全部替换为“%20”。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的”真实“长度<br>常见的做法是从后往前操作。因为尾部有额外的缓冲，可以直接修改，不必担心会覆盖原来的数据。<br>采用这样的方法我们需要扫描两次，第一次先扫描出字符串中的空格数，从而算出字符串的最终长度；第二次扫描才真正开始反向编辑字符串。检测到空格则将%20复制到下一个位置，若不是空白，就复制原先的字符。<br>下面是这个算法的实现代码：  </p>
<pre><code>public void replaceSpaces(char[] str, int length){
    int spaceCount = 0, newLength, i;
    for(i =0 ;i&lt;length; i++){
        if(str[i] == &apos; &apos;){
            spaceCount++;
        }
    }
    newLength = length + sapceCount * 2;
    str[newLenght] = &apos;\0&apos;;
    for(i=length-1; i&gt;=0; i--){
        if(str[i]==&apos; &apos;){
            str[newLength -1] = &apos;0&apos;;
            str[newLength-2]=&apos;2&apos;;
            str[newLength-3]=&apos;%&apos;;
            newLength =newLength-3;
        }else{
            str[newLength-1] =str[i];
            newLength = newLength-1;
        }
    }
}</code></pre><p>因为Java字符串是不可变得，所以我们选用了字符数组来解决这个问题。若直接使用字符串，返回时就要把字符串复制一份，不过，这样做的好处是只扫描了一次。  </p>
<p><strong>问题总结1-5 利用字符重复出现的次数编写一个方法，实现基本的字符串压缩功能</strong>。  </p>
<p>利用字符重复出现的次数编写一个方法，实现基本的字符串压缩功能。比如字符串aabcccccaaa。 若“压缩”后的字符串没有变短，则返回原先的字符串。<br>一般解法：会迭代访问字符串，将字符串拷贝至新字符串，并数出重复字符。  </p>
<pre><code>public String compressBad(String str){
    String mystr=&quot;&quot;;
    char last = str.charAt(0);
    int count=1;
    for(int i=1; i&lt;str.length(); i++){
        if(str.charAt(i) == last){
            count++;
        }else{
            mystr +=last + &quot;&quot; + count;
            count=1;  
        }
    }
    return mystr + last + count;
}</code></pre><p>这段代码并未处理压缩后字符串比原始字符串长的情况。<br>使用StringBuffer优化部分性能  </p>
<pre><code>String compressBetter(String str){
    //检查压缩后的字符串是否会变得更长
    int size=countCompression(str);
    if(size&gt;=str.length()){
        return str;
    }
    StringBuffer mystr= new StringBuffer();
    char last=str.charAt(0);
    for(int i=1; i&lt;str.length(); i++){
        if(str.charAt(i) == last){
            count++;
        }else{
            mystr.append(last);
            mystr.append(count);
            last=str.charAt(i);
            count = 1;
        }
    }
    mystr.append(last);
    mystr.append(count);
    return mystr.toString();
}
int countCompression(String str){
    if(str == null || str.isEmpty()) return 0;
    char last =str.charAt(0);
    int size=0;
    int count=0;
    for(int i=1; i&lt;str.length(); i++){
        if(str.charAt(i) == last){
            count++;
        }else{
            last = str.charAt(i);
            size+=1+String.valueOf(count).length();
            count=1;
        }
    }
    size+=1+String.valueOf(count).length();
    return size;
}</code></pre><hr>
<p>若不使用StringBuffer，可以用算出来压缩后字符串的长度构造出相应大小的字符数组。  </p>
<pre><code>String compressAlternate(String str){
    int size=countCompression(str);
    if(size &gt;= str.lenght()){
        return str;
    }
    char[] array  = new char[size];
    int index = 0;
    char last=str.charAt(0);
    int count=1;
    for(int i=1; i&lt;str.length(); i++){
        if(str.charAt(i) == last){
            count++;
        }else{
            index = setChar(array, last, index, count);
            last = str.charAt(i);
            count = 1;
        }
    }

    index = setChar(array, last, index, count);
    return String.valueOf(array);
}

int setChar(char[] array, char c, int index, int count){
    array[index] = c;
    index++;

    char[] cnt=String.valueOf(count).toCharArray();

    for(char x : cnt){
        array[index] = x;
        index++;
    }
    return index;
}

int countCompression(String str){
    //同之前
}</code></pre><p><strong>1-6旋转图片90度</strong><br>给定一幅由NXN矩阵表示的图像，其中每个像素的大小为4字节，编写一个方法，将图像旋转90度，不占用额外的内存空间。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for i &#x3D; 0  to n</span><br><span class="line">	temp &#x3D; top[i];</span><br><span class="line">	top[i]&#x3D;left[i];</span><br><span class="line">	left[i]&#x3D;bottom[i];</span><br><span class="line">	bottom[i]&#x3D;right[i];</span><br><span class="line">	right[i]&#x3D;temp;</span><br></pre></td></tr></table></figure>

<p>从最外面一层开始逐渐向里，在每一层上执行上述交换。</p>
<pre><code>public void rotate(int[][] matrix, int n){
    for(int layer =0 ; layer &lt; n/2; ++layer){
        int first = layer;
        int last = n - 1 - layer;
        for(int i=first; i&lt;last; ++i){
            int offset = i - first;
            int top = matrix[first][i];
            matrix[first][i] = matrix[last-offset][first];
            matrix[last-offset][first] = matrix[last][last-offset];
            matrix[last][last-offset] = matrix[i][last];
            matrix[i][last] = top;
        }
    }
}</code></pre><p><strong>问题总结1—7 矩阵清0</strong> </p>
<p>编写一个算法，若MxN矩阵中某个元素为0，则将其所在行与列清零。  </p>
<p>新建一个矩阵标记零元素位置，然后，正在第二次遍历矩阵时将零元素所在行与列清零。这样的做法空间复杂度是O(MN).<br>这里具体做法是用两个数组分别记录包含零元素的所在行和列。然后在第二次遍历矩阵时，若所在行或列标记为零，则将元素清为零。  </p>
<pre><code>public void setZero(int[][]matrix){
    boolean[] row = new boolean[matrix.length];
    boolean[] column = new boolean[matrix[0].length];

    //记录0元素所在行索引与列索引
    for(int i=0; i&lt;matrix.length; i++){
        for(int j=0; j&lt;matrix[0].length; j++){
            if(matrix[i][j] == 0){
                row[i]=true;
                column[j]=true;
            }
        }
    }
    //若行i与列j有个元素为0，则将array[i][j]置为0 
    for(int i=0; i&lt;matrix.length; i++){
        for(int j=0; j&lt;matrix[0].length; j++){
            if(row[i] || column[j]){
                matrix[i][j] = 0;
            }
        }
    }
}</code></pre><p><strong>问题总结1—8 检测S2是否是S1旋转而成</strong>  </p>
<p>假设有一个方法isSubstring，可检查一个单词是否为其他字符串的子串。给定两个字符串s1和s2,请编写代码检查s2是否为s1旋转而成，要求只能调用一次isSubstring.(比如waterbottle是erbottlewat旋转后的字符串)  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1&#x3D;xy&#x3D;waterbottle</span><br><span class="line">x&#x3D;wat</span><br><span class="line">y&#x3D;erbottle</span><br><span class="line">s2&#x3D;yx&#x3D;erbottlewat</span><br></pre></td></tr></table></figure>

<p>无论x和y之间的分割点在何处，我们会发现yx肯定是xyxy的子串。  </p>
<pre><code>public boolean isRotation(String s1, String s2)
{
    int Len = s1.length();
    if(len == s2.length() &amp;&amp; len&gt;0){
        //拼接s1和s2，放入新字符串中
        String s1s1 = s1+s1;
        return isSubstring(s1s1,s2);
    }
    return false;
} </code></pre><p><strong>问题总结2—1 链表（移除末排序链表中的重复结点）</strong>  </p>
<p>移除末排序链表中的重复结点<br>进阶：如果不得使用临时缓冲区，该怎么解决？<br>我们会直接迭代访问整个链表，将每个结点加入散表。如果发现有重复元素，则将该结点从链表中移除，然后继续迭代。  </p>
<pre><code>public static void deleteDups(LinkedListNode n){
    Hashtable table = new Hashtable();
    LinkedListNode previous = null;
    while(n != null){
        if(table.containsKey(n.data)){
            previous.next = n.next;
        }else{
            table.put(n.data, true);
            previous = n;
        }
        n=n.next;
    }
}</code></pre><p>进阶：不得使用缓冲区，可以用两个指针来迭代：current迭代刚问整个链表，runner用于检查后续的结点是否重复。  </p>
<pre><code>public  static deleteDups(LinkedListNode head){
    if(head == null) return ;
    LinkedListNode current = head;
    while(current != null){
        LinkedListNode runner = current;
        while(ruuner.next != null){
            if(runner.next.data == current.data){
                runner.next = runner.next.next;
            }else{
                runner = runner.next;
            }
        }
        current = current.next;
    }
}</code></pre><p><strong>问题总结2—2 找出单向链表中倒数第k个结点</strong>  </p>
<p>解法一：链表长度已知<br>若链表长度已知，那么倒数第k个结点就是第(length-k)个结点。直接迭代访问链表就能找到这个结点。不过，这个解法过于简单，可能不会遇到。<br>解法二：递归<br>递归访问整个链表，当抵达链表末端时，该方法回传一个置为0的计数器。之后的每次调用都会将这个计数器加1.当计数器等于k时，表示我们访问的是链表倒数第k个元素。<br>实现代码简洁，前提是我们要有方法通过栈“回传”一个整数值。可惜，我们无法用一般的返回语句传一个结点和一个计数器。<br>方法A：不返回该元素<br>一种方法是对这个问题略调整，只打印倒数第k个结点的值，然后，直接通过返回值传回计数器值。  </p>
<pre><code>public static int nthToLast(LinkedListNode head, int k){
    if(head == null){
        return 0;
    }
    int i=nthToLast(head.next, k) + 1;
    if(i == k){
        System.out.println(head.data);
    }
    return i;
}</code></pre><p>方法B：使用C++<br>第二种解法是使用C++，并通过引用传值。这样一来，我们就可以返回结点值，而且也能通过传递指针更新计数器。  </p>
<pre><code>node* nthToLast(node*  head, int k int&amp; i){
    if(head == NULL){
        return NULL;
    }
    node * nd = nthToLast(head-&gt;next, k, i);
    i = i + 1;
    if(i==k){
        return head;
    }
    return nd;
}</code></pre><p>方法C:创建包裹类<br>这里的难点在于我们无法同时返回计数器和索引值。如果用一个简单的类（或一个单元素数组）包裹计数器值，就可以模仿按引用传递。  </p>
<pre><code>public class IntWrapper{
    public int value = 0;
}
LinkedListNode nthToLastR2(LinkedListNode head, int k, IntWrapper i){
    if(head == null){
        return null;
    }
    LinkedListNode node = nthToLastR2(head.next, k, i);
    i.value = i.value+1;
    if(i.value == k){
        return head;
    }
    return node;
}</code></pre><p>还有不少解法，可以将计数器存放在静态变量中，或者可以创建一个类，存放结点和计数器，并返回这个类的实例。不论选用哪种解法，我们都要设法更新结点和计数器，并在每层递归调用的栈都能访问到。  </p>
<p>解法3：迭代法<br>可以使用两个指针p1和p2，并将它们指向链表中相距k个结点的两个结点，具体做法是先将p1和p2指向链表首结点，然后将p2向前移动k个结点。之后，我们以相同的速度移动到这两个指针，p2会移动LENGTH - k步后抵达链表尾结点。此时，p1会指向链表第LENGTH-K个结点，或者说倒数第K个结点。  </p>
<pre><code>LinkedListNode nthToLast(LinkedListNode head, int k)
{
    if(k&lt;=0) return null;
    LinkedListNode p1=head;
    LinkedListNode p2=head;

    //p2向前移动k个结点
    for(int i=0; i&lt;k-1; i++){
        if(p2 == null) return null;
        p2= p2.next;
    }
    if(p2 == null) return null;

    //现在以同样的速度移动p1和p2，当p2抵达链表末尾时，p1刚好指向倒数第k个结点
    while(p2.next != null){
        p1=p1.next;
        p2=p2.next;
    }
    return p1;
}</code></pre><p><strong>问题总结2—3 删除链表中某个结点</strong>      </p>
<p> 删除单向链表中的某个结点，假定你只能访问该结点。  </p>
<pre><code>public static boolean deleteNode(LinkedListNode n){
    if(n==null || n.next == null){
        return false;
    }
    LinkedListNode next= n.next;
    n.data=next.data;
    n.next=next.next;
    return true;
}</code></pre><p><strong>问题总结2—4 分割链表</strong>    </p>
<p>以给定值x为基准将链表分割成两部分，所有小于x的结点排在大于或等于x的结点之前。<br>我们不必移动和交换元素，可以直接创建两个链表：一个链表存放小于x的元素；另一个链表存放大于或等于x的元素。<br>我们会迭代访问整个链表，将元素插入before或after链表。一旦抵达链表末端，则表明拆分完成，最后合并两个链表。  </p>
<pre><code>public LinkedListNode partition(LinkedListNode node, int x){
    LinkedListNode beforeStart = null;
    LinkedListNode beforeEnd = null;
    LinkedListNode afterStart = null;
    LinkedListNode afterEnd = null;

    //分割链表
    while(node!=null){
        LinkedListNode next = node.next;
        node.next = null;
        if(node.data &lt; x)
        {
            //将结点插入before链表
            if(beforeStart == null){
                beforeStart = node;
                beforeEnd = beforeStart;
            }else{
                beforeEnd.next = node;
                beforeEnd = node;
            }
        }
        else{
            //将结点插入after链表
            if(afterStart == null){
                afterStart = node;
                afterEnd = afterStart;
            }else{
                afterEnd.next = node;
                afterEnd = node;
            }
        }
        node = next;
    }
    if(beforeStart == null){
        return afterStart;
    }
    //合并before和after
    beforeEnd.next = afterStart;
    return beforeStart;
}</code></pre><p>第二种解法：结点不再追加至before和after链表的末端，而是插入这两个链表的前端。  </p>
<pre><code>public LinkedListNode partition(LinkedListNode node, int x){
    LinkedListNode beforeStart = null;
    LinkedListNode afterStart = null;
    /*分割链表*/
    while(node != null){
        LinkedListNode next = node.next;
        if(node.data &lt; x){
            //将结点插入before链表的前端
            node.next = beforeStart;
            beforeStart = node;
        }else{
              //将结点插入after链表的前端
            node.next = afterStart;
            afterStart = node;
        }
        node = next;
    }
    //合并before链表和after链表
    if(beforeStart == null){
        return afterStart;
    }

    //定位至before链表末尾，合并两个链表
    LinkedListNode head = beforeStart;
    while(beforeStart.next != null){
        beforeStart = beforeStart.next;
    }
    beforeStart.next = afterStart;

    return head;
}</code></pre><p><strong>问题总结2—5 两个链表数据求和</strong>  </p>
<p>给定两个用链表表示的整数，每个结点包含一个数位，这些数位是反向存放的，也就是个位在链表首部。编写函数对这两个整数求和，并用链表形式返回结果。<br>进阶：<br>假设这些数位是正向存放的，请再做一遍；  </p>
<pre><code>LinkedListNode addList(LinkedListNode l1, LinkedListNode l2, int carry){
    //两个链表全部为空且进位为0，则函数返回
    if(l1==null &amp;&amp; l2==null &amp;&amp; carry==0){
        return null;
    }
    LinkedListNode result = new LinkedListNode();

    //将value以及l1和l2的data相加
    int value = carry;
    if(l1 != null){
        value += l1.data;
    }
    if(l2 != null){
        value += l2.data;
    }
    result.data = value % 10;     //求和结果的个位
    //递归
    LinkedListNode more = addLists(l1 == null ? null : l1.next, l2 == null ? null : l2.next,  value &gt;= 10 ? 1 : 0);
    result.setNext(more);
    return result;
}</code></pre><p>进阶：<br>（1）一个链表的结点可能比另一个链表的少，我们无法直接处理这种情况。例如，假设要对（1-&gt;2-&gt;3-&gt;4）与（5-&gt;6-&gt;7）求和，应该5与2配对求和，对此我们一开始先比较两个链表的长度并用0填充较短的链表。<br>(2)  </p>
<pre><code>public class PartialSum{
    public LinkedListNode sum =null;
    public int carry = 0;
}

LinkedListNode addLists(LinkedListNode l1, LinkedListNode l2){
    int len1 = length(l1);
    int len2 = length(l2);

    //用零填充较短的链表
    if(len1 &lt; len2){
        l1 = padList(l1, len2 - len1);
    }else{
        l2 = padList(l2, len1 - len2);
    }
    //对两个链表求和
    PartialSum sum = addListsHelper(l1, l2);

    //如有进位，则插入链表首部，否则直接返回整个链表
    if(sum.carry == 0){
        return sum.sum;
    }else{
        LinkedlistNode result = insertBefore(sum.sum, sum.carry);
        return result;
    }
}

PartialSum addListsHelper(LinkedListNode l1, LinkedListNode l2){
    if(l1 == null &amp;&amp; l2 == null){
        PartialSum sum = new PartialSum();
        return sum;
    }
    //对较小数字递归求和
    PartialSum sum = addListHelper(l1.next, l2.next);

    //将进位和当前数据相加
    int val = sum.carry + l1.data + l2.data;

    //插入当前数字的求和结果
    LinkedListNode full_result = insertBefore(sum.sum, val % 10);

    //返回求和结果和进位值
    sum.sum = full_result;
    sum.carry = val / 10;
    return sum;
}

//用零填充链表
LinkedListNode padList(LinkedListNode l ,int padding){
    LinkedListNode head = l;
    for(int i =0; i&lt;padding; i++){
        LinkedListNode n = new LinkedListNode(0, null, null);
        head.prev = n;
        n.next =head;
        head = n;
    }
    return head;
}

//辅助函数，将结点插入链表首部
LinkedListNode insertBefore(LinkedListNode list, int data){
    LinkedListNode node = new LinkedListNode(data, null, null);
    if(list != null){
        list.prev = node;
        node.next = list;
    }
    return node;
}</code></pre><p><strong>问题总结2-6 给定一个有环链表，实现一个算法返回环路的开头结点</strong>  </p>
<p>第一部分：检测链表是否存在环路<br>有一种简单的做法叫FastRunner/SlowRunner，就像两辆赛车绕着同一赛道以不同速度前进最终会碰在一起。<br>第二部分：什么时候碰在一起<br>第三部分：如何找到环路起始处<br>第四部分：将全部整合在一起  </p>
<pre><code>LinkedListNode FindBeginning(LinkedListNode head){
    LinkedListNode slow = head;
    LinkedListNode fast = head;

    //**找出碰撞点，将处于链表中LOOP_SIZE - k步的位置
    while(fast != null &amp;&amp; fast.next != null){
        slow = slow.next;
        fast = fast.next.next;
        if(slow == fast){   //碰撞
            break;
        }
    }

    //错误检查，没有碰撞处，也就是没有环路
    if(fast == null || fast.next == null){
        return null;
    }

    //将slow 指向首部，fast指向碰撞处，两者距离环路
    起始处k步，若两者以相同速度移动，则必定会在环路起始处碰在一起。

    slow = head;
    while(slow != fast){
        slow = slow.next;
        fast = fast.next;
    }
    return fast;
}</code></pre><p>问题总结2-7 检查链表是否为回文      </p>
<p>0-&gt;1-&gt;2-&gt;1-&gt;0       </p>
<p>解法1：反转比较<br>在比较原始链表和反转链表时，只需比较链表的前半部分，若原始链表和反转链表的前半部分相同，那么两者的后半部分肯定想通。<br>解法2：迭代法<br>只需将链表前半部分反转，利用栈来实现。<br>若链表长度已知，可以用标准for迭代访问前半部分结点，将每个结点入栈，要小心处理奇数情况。<br>若链表长度未知，可以利用本章开头描述的快慢runner方法迭代访问链表。在迭代循环的每一步，将慢速runner的数据入栈。在快速runner抵达链表尾部时，慢速runner刚好位于链表中间位置。至此，栈里就存放了链表前半部分的所有结点，不过顺序是相反的。<br>接下来，我们只需迭代访问链表余下结点。每次迭代时，比较当前结点和栈顶元素，若完成迭代时比较结果完全相同，则该链表是回文序列。  </p>
<pre><code>boolean isOalindrome(LinkedListNode head){
    LinkedListNode fast = head;
    LinkedListNode slow = head;

    Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();

    //将链表前半部分元素入栈，当快速runner到达链表尾部时，则慢
    速runner已处在链表中间位置
    while(fast != null &amp;&amp; fast.next != null){
        stack.push(slow.data);
        slow=slow.next;
        fast=fast.next.next;
    }

    //链表有奇数个元素，跳过中间元素
    if(fast != null){
        slow = slow.next;
    }

    while(slow != null){
        int top = stack.pop().intValue();

        //两者不同，则该链表不是回文序列
        if(top != slow.data){
            return false;
        }
        slow = slow.next;
    }
    return true;
}</code></pre><p>解法3：递归法<br>记号说明：用记号Kx表示结点时，变量K指示结点数据的值，而x（取f或b）指示该结点是值为K的前方结点还是后方结点。<br>结点3b指的是值为3的第二个（b-&gt;back，即后方）结点。<br>0（1（2（3）2）1）0<br>为了运用这种方法，首先必须知道什么时候到达中间元素，这也形成了递归的终止条件。每次递归调用传入length-2为长度，当长度等于0或1时，表明当前已处于链表的中间位置。  </p>
<pre><code>recurse(Node n, int length){
    if(length == 0 || length ==1){
        return [something];
    }
    recurse(n.next, length-2);
    ...
}


class Result{
    public LinkedListNode node;
    public boolean result;
}

Result isPalindromeRecurse(LinkedListNode head, int length){
    if(head == null || length == 0){
        return new Result(null, true);
    }
    else if(length == 1){
        return new Result(head.next, true);
    }
    else if(length == 2){
        return new Result(head.next.next, head.data == head.next.data);
    }
    Result res = isPalindromeRecurse(head.next, length - 2);
    if(!res.result || res.node == null){
        return res;
    }
    else{
        res.result = head.data == res.node.data;
        res.node = res.node.next;
        return res;
    }
}

boolean isPalindrome(LinkedListNode head){
    Result p = isPalindrome(head, listSizr(head));
    return p.result;
}</code></pre><p><strong>问题总结3-1 如何只用一个数组实现三个栈</strong>  </p>
<p>问题总结3-5 实现一个MyQueue类，该类用两个栈实现一个队列<br>队列和栈的主要区别在于元素进出顺序（先进先出和后进后出）  </p>
<pre><code>public class MyQueue&lt;T&gt; {
    Stack&lt;T&gt; stackNewest, stackOldest;

    public MyQueue(){
        stackNewest = new Stack&lt;T&gt;();
        stackNewest = new Stack&lt;T&gt;();
    }
    public int size(){
        return stackNewest.size() +stackOldest.size();
    }

    public void add(T value){
        stackNewest.push(value);
    }

    private void shiftStacks(){
        if(stackOldest.isEmpty()){
            while(!stackNewest.isEmpty()){
                stackOldest.push(stckNewest.pop());
            }
        }
    }
    public T peek(){
        shiftStack();
        return stackOldest().peek();
    }
    public T remove(){
        shiftStacks();
        return stackOldest.pop();
    }
}</code></pre><p><strong>问题总结4-1 实现一个函数，检查二叉树是否平衡</strong><br>平衡树：任意一个结点，其两棵子树的高度差不超过1  </p>
<p>直接递归访问整课树，计算每个结点两棵子树的高度。  </p>
<pre><code>pulic static int getHeight(TreeNode root){
    if(root == null) return 0;
    return Math.max(getHeight(root.left),
                                    getHeight(root.right)) + 1;
}

public static boolean isBalanced(TreeNode root){
    if(root == null) return true;
    int heightDiff = getHeight(root.left) - getHeight(root.right);
    if(Math,abs(heightDiff) &gt; 1){
        return false;
    }
    else{
        return isBalanced(root.left) &amp;&amp; isBalanced(root.right);
    }
}</code></pre><p>上面的方法你会发现，getHeight不仅可以检查高度，还能检查这棵树是否平衡。<br>改进的算法会从根结点递归向下检查每棵子树的高度，我们会通过checkHeight方法，以递归方式获取每个结点左右子树的高度。若子树是平衡的，则checkHeight返回该子树的实际高度。<br>若子树不平衡，则checkHeight返回-1.checkHeight会立即中断执行，并返回-1；  </p>
<pre><code>public static int checkHeight(TreeNode root){
    if(root == null){
        return 0;
    }
    检查左子树是否平衡
    int leftHeight = checkHeight(root.left);
    if(leftHeight == -1){
        return -1;
    }
    int rightHeight = checkHeight(root.right);
    if(rightHeight == -1){
        return -1;
    }

    int heightDiff = leftHeight - rightHeight;
    if(Math.abs(heightDiff) &gt; 1){
        return -1;
    }
    else{
        return Math.max(leftHeight, rightHeight) + 1;
    }
}

public static boolean isBalanced(TreeNode root){
    if(checkHeight(root) == -1){
        return false;
    }else{
        return true;
    }
}</code></pre><p><strong>问题总结4-2 给定有向图，设计一个算法，找出两个结点之间是否存在一条路径</strong><br>只需通过图的遍历，比如深度优先搜索或广度优先搜索等，就能解决这个问题。<br>我们从两个结点的其中一个出发，在遍历过程中，检查是否找到另一个结点。在这个算法中，访问过的结点都应标记为“已访问”，以免循环和重复访问结点。  </p>
<pre><code>public enum State{
    Unvisited, Visited, Visiting;
}

public static boolean search(Graph g, Node start, Node end){
    //当作队列使用
    LinkedList&lt;Node&gt; q = new LinkedList&lt;Node&gt;();

    for(Node u : g.getNodes()){
        u.state = State.Unvisited;
    }
    start.state =  State.Visiting;
    q.add(start);
    Node u;
    while(!q.isEmpty()){
        u = q.removeFirst();
        if(u != null){
            for(Node v : u.getAdjacent()){
                if(v.state == State.Unvisited){
                    if(v == end){
                        return true;
                    }
                    else{
                        v.state = State.Visiting;
                        q.add(v);
                    }
                }
            }
            u.state = State.Visited;
        }
    }
    return false;
}</code></pre><p>深度优先搜索实现比较简单，因为只需要递归即可。<br>广度优先搜索很适合用来查找最短路径，而深度优先搜索在访问邻近结点之前，可能会先深度遍历其中一个邻近结点。  </p>
<p><strong>问题总结4-3 给定一个有序整数数组，元素各部相同且按升序排列，编写一个算法，创建一颗高度最小的二叉查找树</strong>  </p>
<p>要创建一颗高度最小的树，就必须让左右子树的结点数量越接近越好。也就是说，我们让数组中间的中间的值成为根结点，这样一来，数组左边一半就成为左子树，右边一半就成为右子树。<br>（1）将数组中间位置的元素插入树中<br>（2）将数组左半边元素插入左子树<br>（3）将数组右半边元素插入右子树  </p>
<pre><code>TreeNode createMinimalBST(int arr[], int start, int end){
    if(end &lt; start){
        return null;
    }
    int mid = (start + end) / 2;
    TreeNode n = new TreeNode(arr[mid]);
    n.left = createMinimalBST(arr, startm mid -1);
    n.right = createMinimalBST(arr, mid+1, end);
    return n;
}

TreeNode createMinimalBST(int array[]){
    return createMinimalBST(array, 0, array.length -1);
}</code></pre><p>问题总结4-5 检查一棵二叉树是否为二叉查找树  </p>
<p>解法1：中序遍历<br>将所有元素复制到数组中，看是否是有序的。（假定树中不包含重复值）  </p>
<pre><code>public static int index = 0;
public static void copyBST(TreeNode root, int[] array){
    if(root == null) return ;
    copyBST(root.left, array);
    array[index] = root.data;
    index++;
    copyBST(root.right, array);
}

public static boolean checkBST(TreeNode root){
    int[] array = new int[root.size];
    copyBST(root, array);
    for(int i=1; i&lt;array.length; i++){
        if(array[i] &lt;= array[i-1]) return false;
    }
    return true;
}</code></pre><p>数组可以去掉，可以在比较时，直接记下最后的元素  </p>
<pre><code>public static int last_printed = Integer.MIN_VALUE;
public static boolean checkBST(TreeNode n){
    if(n == null) return true;
    //递归检查左子树
    if(!checkBST(n.left)) return false;
    //检查当前结点
    if(n.data &lt;= last_printed) return false;
    last_printed = n.data;

    //递归检查右子树
    if(!checkBST(n.right)) return false;

    return true;
}</code></pre><p>最小/最大法  </p>
<pre><code>boolean checkBST(TreeNode n){
    return checkBST(n, Integer.MIN_VALUE, Integer.MAX_VALUE);
}
boolean checkBST(TreeNode n, int min, int max){
    if(n==null){
        return true;
    }
    if(n.data &lt; min || n.data &gt;= max){
        return false;
    }

    if(!checkBST(n.left, min, n.data) || ！checkBST(n.right, n.data, max)){
        return false;
    }
    return true;
}</code></pre>
      
      <!-- reward -->
      
      <div id="reward-btn">
        打赏
      </div>
      
    </div>
    
    
      <!-- copyright -->
      
        <div class="declare">
          <ul class="post-copyright">
            <li>
              <i class="ri-copyright-line"></i>
              <strong>版权声明： </strong>
              本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
            </li>
          </ul>
        </div>
        
    <footer class="article-footer">
      
          
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://yoursite.com/2020/04/28/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E3%80%8B/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>
      
      

    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="/2020/04/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            数据结构-哈希表
          
        </div>
      </a>
    
    
      <a href="/2020/04/28/%E7%BC%96%E8%BE%91%E9%83%A8%E7%9A%84%E6%95%85%E4%BA%8B/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">编辑部的故事</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        app_id: 'bbpQw161m67zfpKoIaX0DjRP-gzGzoHsz',
        app_key: '1OB4hLIBzNt40C7AAQ3ImBWG',
        path: window.location.pathname,
        notify: 'false',
        verify: 'false',
        avatar: 'monsterid',
        placeholder: '给我的文章加点评论吧~',
        recordIP: true
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
  
  
  
  
<!-- minivaline评论 -->
<div id="mvcomments-box">
    <div id="mvcomments">
    </div>
</div>
<script src='https://cdn.jsdelivr.net/npm/minivaline/dist/MiniValine.min.js'></script>
<script>
	new MiniValine({
	  el: '#mvcomments',
	  appId: 'bbpQw161m67zfpKoIaX0DjRP-gzGzoHsz',
	  appKey: '1OB4hLIBzNt40C7AAQ3ImBWG',
	  placeholder: 'Write a Comment',
	  lang: '',
	  adminEmailMd5: '',
	  math: true,
	  md: true
	});
    const infoEle = document.querySelector('#mvcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #mvcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #mvcomments-box {
            padding: 5px 0px;
        }
    }

    #mvcomments-box #mvcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2020
        <i class="ri-heart-fill heart_icon"></i> Chen Bin
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="梦想岛"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">算法与程序设计</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E4%BB%A3%E7%A0%81%E8%AF%B4/">代码说</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="http://chenbin-vip.lofter.com" target="_blank" rel="noopener">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E5%A4%96%E8%AF%AD%E5%AD%A6%E4%B9%A0/">外语学习</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84/">法律法规</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/about/">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://i.loli.net/2020/04/24/VjamHOiTgk26EpK.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://i.loli.net/2020/04/24/FMJN75HGXRpDdP4.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Subtitle -->

<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
      startDelay: 0,
      typeSpeed: 180,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
    console.log(err)
  }
</script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>

<!-- Katex -->


    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css">
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"></script>
        
    


<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->


<script src="/js/clickLove.js"></script>


<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>



    
  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

</html>