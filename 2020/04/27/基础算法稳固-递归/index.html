<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="学习，生活，思考，代码，博客" />
   
  <meta name="description" content="梦想的萌生岛" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    基础算法稳固-递归 |  梦想岛
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

<link rel="alternate" href="/atom.xml" title="梦想岛" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      <section class="outer">
  <article id="post-基础算法稳固-递归" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  基础算法稳固-递归
</h1>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/04/27/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%A8%B3%E5%9B%BA-%E9%80%92%E5%BD%92/" class="article-date">
  <time datetime="2020-04-27T08:44:38.000Z" itemprop="datePublished">2020-04-27</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">算法与程序设计</a>
  </div>

      
      
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">6.7k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">26 分钟</span>
        </span>
    </span>
</div>

      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>2020-4-20 我感觉递归的思维是从小入手，小得满足大的也满足，步步验证合理性。  </p>
<pre><code>/*接受一个整型值（无符号0，把它转换为字符并打印它，前导零被删除*/
#include &lt;stdio.h&gt;
int binary_to_ascii(unsigned int value){
    unsigned int quotient;
    quotient = value / 10;
    if(quotient != 0){
        binary_to_ascill(quotient);
    }
    putchar(value % 10 + &apos;0&apos;);
}</code></pre><a id="more"></a>
<p>这个函数的工作流程：  </p>
<blockquote>
<p>1.将参数值除以10<br>2.如果quotient的值为非零，调用binary-to-ascii打印quotient当前值的各位数字<br>3.接着，打印步骤1中除法运算的余数  </p>
</blockquote>
<p>追踪一个递归函数的执行过程的关键是理解函数中所声明的变量是如何存储的。当函数被调用时，它的变量的空间是创建于运行时堆栈上的。以前调用的函数的变量仍保留在堆栈上，但他们被新函数的变量所掩盖，因此是不能被访问的。  </p>
<p>当递归函数调用自身时，情况于是如此。每进行一次新的调用，都将创建一批变量，他们将掩盖递归函数前一次调用所创建的变量。当我追踪一个递归函数的执行过程时，必须把分数不同次调用的变量区分开来，以避免混淆。  </p>
<pre><code>int fun(int n){
    if(n==1) return 1;
    return n+fun(n-1);
}
int main(void){
    printf(&quot;10以内的自然数之和是%d&quot;,fun(10));
    return 0;
}</code></pre><p>设计递归函数基本上只考虑它的第一层就可以了，设计它甚至比设计普通函数要简单  。</p>
<blockquote>
<p>1.首先我们要想，函数fun应该设计成一个怎样的功能？这是最重要的一环<br>主要看需求，满足需求的情况下微调即可。比如输入10，输出10以内自然数之和。<br>2.确定好功能后，接着就是要实现功能了<br>比如fun首先会受到10，但不能原封不动的把自己的参数给2号fun,即不能给他10，至少要改变一点吧。<br>3.想办法结束递归<br>递归也是一种循环，循环语句尚且有结束循环的条件，递归当然也有。<br>但要注意！这个结束的条件需要放在调用函数之前，因为不这样会永无止境的循环递归下去，控制流始终无法结束条件。  </p>
</blockquote>
<p>根据收到的参数与给2号的参数的差来考虑结束条件。（简单说是让1号和2号的参数衔接，不要出现断层）<br>以及从递归结构的尾端的角度来验证正确性。<br>（简单来说就是去测试几个边缘值看会不会死循环）。  </p>
<p>概括就是根据参数设条件，以及验证  。<br>比如fun收到的是n，传给2号的是n-2，中间少了n-1,那么1号fun就应该考虑n和n-1两种最简单的情况，比如可以认为n为1或0时最简：  </p>
<pre><code>int fun(int n){
       if(n==1 || n==0){
        return n;
       }
    return n+n-1 +fun(n-2);
}</code></pre><p>也可以认为n为1和2时最简：  </p>
<pre><code>int fun（int n）
{
    if(n==1){
        return 1;
    }
    if(n==2){
        return 2+1;
    }
    return n+n-1+fun(n-2);
} </code></pre><p>如果担心n的参数为0或负数等错误情况，另加一个结束条件。  </p>
<pre><code>int fun(int n){
    if(n&lt;=0){
        return 0;
    }
    if(n==1){
        return 1;
    }
    if(n==2){
        return 2+1;
    }
    return n+n-1+fun(n-2);
}</code></pre><h2 id="归纳总结："><a href="#归纳总结：" class="headerlink" title="归纳总结："></a>归纳总结：</h2><blockquote>
<p><strong>1.设定好函数的功能（包括参数和返回值的设计），这是最关键的一环。</strong><br><strong>2.将自身作为一个普通函数来调用，认定它能完成它的工作。</strong><br><strong>3.调用自身时给的参数不能和自己的完全相同。</strong><br><strong>4.将一个最简单的情况作为结束条件，放在调用自身之前。</strong><br><strong>5.检查结束条件是否疏漏。</strong> </p>
</blockquote>
<h2 id="分割线–另一个版本教程"><a href="#分割线–另一个版本教程" class="headerlink" title="分割线–另一个版本教程"></a>分割线–另一个版本教程</h2><p>递归算法讲解<br><a href="https://blog.csdn.net/sinat_38052999/article/details/73303111" target="_blank" rel="noopener">https://blog.csdn.net/sinat_38052999/article/details/73303111</a><br>摘要：<br>大师 L. Peter Deutsch 说过：To Iterate is Human, to Recurse,   Divine.中文译为：人理解迭代，神理解递归。毋庸置疑地，递归确实是一个奇妙的思维方式。对一些简单的递归问题，我们总是惊叹于递归描述问题的能力和编写代码的简洁，但要想真正领悟递归的精髓、灵活地运用递归思想来解决问题却并不是一件容易的事情。本文剖析了递归的思想内涵，分析了递归与循环的联系与区别，给出了递归的应用场景和一些典型应用，并利用递归和非递归的方式解决了包括阶乘、斐波那契数列、汉诺塔、杨辉三角的存取、字符串回文判断、字符串全排列、二分查找、树的深度求解在内的八个经典问题。<br>一. 引子<br>大师 L. Peter Deutsch 说过：To Iterate is Human, to Recurse,   Divine.中文译为：人理解迭代，神理解递归。毋庸置疑地，递归确实是一个奇妙的思维方式。对一些简单的递归问题，我们总是惊叹于递归描述问题的能力和编写代码的简洁，但要想真正领悟递归的精髓、灵活地运用递归思想来解决问题却并不是一件容易的事情。在正式介绍递归之前，我们首先引用知乎用户李继刚(<a href="https://www.zhihu.com/question/20507130/answer/15551917)对递归和循环的生动解释：" target="_blank" rel="noopener">https://www.zhihu.com/question/20507130/answer/15551917)对递归和循环的生动解释：</a><br>递归：你打开面前这扇门，看到屋里面还有一扇门。你走过去，发现手中的钥匙还可以打开它，你推开门，发现里面还有一扇门，你继续打开它。若干次之后，你打开面前的门后，发现只有一间屋子，没有门了。然后，你开始原路返回，每走回一间屋子，你数一次，走到入口的时候，你可以回答出你到底用这你把钥匙打开了几扇门。<br>循环：你打开面前这扇门，看到屋里面还有一扇门。你走过去，发现手中的钥匙还可以打开它，你推开门，发现里面还有一扇门（若前面两扇门都一样，那么这扇门和前两扇门也一样；如果第二扇门比第一扇门小，那么这扇门也比第二扇门小，你继续打开这扇门，一直这样继续下去直到打开所有的门。但是，入口处的人始终等不到你回去告诉他答案。<br>上面的比喻形象地阐述了递归与循环的内涵，那么我们来思考以下几个问题：<br>什么是递归呢？<br>递归的精髓(思想)是什么？<br>递归和循环的区别是什么？<br>什么时候该用递归？<br>使用递归需要注意哪些问题？<br>递归思想解决了哪些经典的问题？<br>这些问题正是笔者准备在本文中详细阐述的问题。<br>二. 递归的内涵<br>1、定义 (什么是递归？)<br>在数学与计算机科学中，递归(Recursion)是指在函数的定义中使用函数自身的方法。实际上，递归，顾名思义，其包含了两个意思：递 和 归，这正是递归思想的精华所在。<br>2、递归思想的内涵(递归的精髓是什么？)<br>正如上面所描述的场景，递归就是有去（递去）有回（归来），如下图所示。“有去”是指：递归问题必须可以分解为若干个规模较小，与原问题形式相同的子问题，这些子问题可以用相同的解题思路来解决，就像上面例子中的钥匙可以打开后面所有门上的锁一样；“有回”是指 :    这些问题的演化过程是一个从大到小，由近及远的过程，并且会有一个明确的终点(临界点)，一旦到达了这个临界点，就不用再往更小、更远的地方走下去。最后，从这个临界点开始，原路返回到原点，原问题解决。    </p>
<p><img src="https://i.loli.net/2020/04/28/DuFUB8RWrA15Ysh.png" alt=""></p>
<p>更直接地说，递归的基本思想就是把规模大的问题转化为规模小的相似的子问题来解决。特别地，在函数实现时，因为解决大问题的方法和解决小问题的方法往往是同一个方法，所以就产生了函数调用它自身的情况，这也正是递归的定义所在。格外重要的是，这个解决问题的函数必须有明确的结束条件，否则就会导致无限递归的情况。<br>3、用归纳法来理解递归<br>数学都不差的我们，第一反应就是递归在数学上的模型是什么，毕竟我们对于问题进行数学建模比起代码建模拿手多了。观察递归，我们会发现，递归的数学模型其实就是     数学归纳法，这个在高中的数列里面是最常用的了，下面回忆一下数学归纳法。<br>数学归纳法适用于将解决的原问题转化为解决它的子问题，而它的子问题又变成子问题的子问题，而且我们发现这些问题其实都是一个模型，也就是说存在相同的逻辑归纳处理项。当然有一个是例外的，也就是归纳结束的那一个处理方法不适用于我们的归纳处理项，当然也不能适用，否则我们就无穷归纳了。总的来说，归纳法主要包含以下三个关键要素：<br>步进表达式：问题蜕变成子问题的表达式<br>结束条件：什么时候可以不再使用步进表达式<br>直接求解表达式：在结束条件下能够直接计算返回值的表达式<br>事实上，这也正是某些数学中的数列问题在利用编程的方式去解决时可以使用递归的原因，比如著名的斐波那契数列问题。<br>4、递归的三要素<br>在我们了解了递归的基本思想及其数学模型之后，我们如何才能写出一个漂亮的递归程序呢？笔者认为主要是把握好如下三个方面：<br>1、明确递归终止条件；    </p>
<p>2、给出递归终止时的处理办法；     </p>
<p>3、提取重复的逻辑，缩小问题规模。     </p>
<p>1). 明确递归终止条件<br>我们知道，递归就是有去有回，既然这样，那么必然应该有一个明确的临界点，程序一旦到达了这个临界点，就不用继续往下递去而是开始实实在在的归来。换句话说，该临界点就是一种简单情境，可以防止无限递归。<br>2). 给出递归终止时的处理办法<br>我们刚刚说到，在递归的临界点存在一种简单情境，在这种简单情境下，我们应该直接给出问题的解决方案。一般地，在这种情境下，问题的解决方案是直观的、容易的。<br>3). 提取重复的逻辑，缩小问题规模*<br>我们在阐述递归思想内涵时谈到，递归问题必须可以分解为若干个规模较小、与原问题形式相同的子问题，这些子问题可以用相同的解题思路来解决。从程序实现的角度而言，我们需要抽象出一个干净利落的重复的逻辑，以便使用相同的方式解决子问题。<br>5、递归算法的编程模型<br>在我们明确递归算法设计三要素后，接下来就需要着手开始编写具体的算法了。在编写算法时，不失一般性，我们给出两种典型的递归算法设计模型，如下所示。<br>模型一： 在递去的过程中解决问题   </p>
<pre><code>function recursion(大规模){
    if (end_condition){      // 明确的递归终止条件
        end;   // 简单情景
    }else{            // 在将问题转换为子问题的每一步，解决该步中剩余部分的问题
        solve;                // 递去
        recursion(小规模);     // 递到最深处后，不断地归来
    }
}</code></pre><p>模型二： 在归来的过程中解决问题    </p>
<pre><code>unction recursion(大规模)
{ 
    if (end_condition){ // 明确的递归终止条件 
        end; // 简单情景 
    }else{ // 先将问题全部描述展开，再由尽头“返回”依次解决每步中剩余部分的问题 
        recursion(小规模); // 递去 
        solve; // 归来 
    } 
}</code></pre><p>6、递归的应用场景<br>在我们实际学习工作中，递归算法一般用于解决三类问题：<br>(1). 问题的定义是按递归定义的（Fibonacci函数，阶乘，…）；<br>(2). 问题的解法是递归的（有些问题只能使用递归方法来解决，例如，汉诺塔问题，…）；<br>(3). 数据结构是递归的（链表、树等的操作，包括树的遍历，树的深度，…）。<br>在下文我们将给出递归算法的一些经典应用案例，这些案例基本都属于第三种类型问题的范畴。<br>三. 递归与循环<br>递归与循环是两种不同的解决问题的典型思路。递归通常很直白地描述了一个问题的求解过程，因此也是最容易被想到解决方式。循环其实和递归具有相同的特性，即做重复任务，但有时使用循环的算法并不会那么清晰地描述解决问题步骤。单从算法设计上看，递归和循环并无优劣之别。然而，在实际开发中，因为函数调用的开销，递归常常会带来性能问题，特别是在求解规模不确定的情况下；而循环因为没有函数调用开销，所以效率会比递归高。递归求解方式和循环求解方式往往可以互换，也就是说，如果用到递归的地方可以很方便使用循环替换，而不影响程序的阅读，那么替换成循环往往是好的。问题的递归实现转换成非递归实现一般需要两步工作：<br>(1). 自己建立“堆栈(一些局部变量)”来保存这些内容以便代替系统栈，比如树的三种非递归遍历方式；<br>(2). 把对递归的调用转变为对循环处理。<br>特别地，在下文中我们将给出递归算法的一些经典应用案例，对于这些案例的实现，我们一般会给出递归和非递归两种解决方案，以便读者体会。   </p>
<p>四. 经典递归问题实战<br>        1. 第一类问题：问题的定义是按递归定义的<br>(1). 阶乘<br>    /**<br>     * Title: 阶乘的实现<br>     * Description:<br>     *      递归解法<br>     *      非递归解法<br>     * @author rico<br>     */</p>
<pre><code>public class Factorial {
    /**     
     * @description 阶乘的递归实现
     * @author rico       
     * @created 2017年5月10日 下午8:45:48     
     * @param n
     * @return     
     */
    public static long f(int n){
        if(n == 1)   // 递归终止条件 
            return 1;    // 简单情景

        return n*f(n-1);  // 相同重复逻辑，缩小问题的规模
    }

--------------------------------我是分割线-------------------------------------

    /**     
     * @description 阶乘的非递归实现
     * @author rico       
     * @created 2017年5月10日 下午8:46:43     
     * @param n
     * @return     
     */
    public static long f_loop(int n) {
        long result = n;
        while (n &gt; 1) {
            n--;
            result = result * n;
        }
        return result;
    }
}</code></pre><p>(2). 斐波纳契数列<br>/** </p>
<ul>
<li><p>Title: 斐波纳契数列 </p>
</li>
<li></li>
<li><p>Description: 斐波纳契数列，又称黄金分割数列，指的是这样一个数列：1、1、2、3、5、8、13、21、…… </p>
</li>
<li><p>在数学上，斐波纳契数列以如下被以递归的方法定义：F0=0，F1=1，Fn=F(n-1)+F(n-2)（n&gt;=2，n∈N*）。 </p>
</li>
<li></li>
<li><p>两种递归解法：经典解法和优化解法 </p>
</li>
<li><p>两种非递归解法：递推法和数组法 </p>
</li>
<li><ul>
<li><p>@author rico</p>
</li>
<li><p>/</p>
<pre><code>public class FibonacciSequence {
     /**
     * @description 经典递归法求解
     * 
     * 斐波那契数列如下：
     * 
     *  1,1,2,3,5,8,13,21,34,...
     * 
     * *那么，计算fib(5)时，需要计算1次fib(4),2次fib(3),3次fib(2)，调用了2次fib(1)*，即：
     * 
     *  fib(5) = fib(4) + fib(3)
     *  
     *  fib(4) = fib(3) + fib(2) ；fib(3) = fib(2) + fib(1)
     *  
     *  fib(3) = fib(2) + fib(1)
     *  
     * 这里面包含了许多重复计算，而实际上我们只需计算fib(4)、fib(3)、fib(2)和fib(1)各一次即可，
     * 后面的optimizeFibonacci函数进行了优化，使时间复杂度降到了O(n).
     * 
     * @author rico
     * @created 2017年5月10日 下午12:00:42
     * @param n
     * @return
     */
    public static int fibonacci(int n) {
        if (n == 1 || n == 2) {     // 递归终止条件
            return 1;       // 简单情景
        }
        return fibonacci(n - 1) + fibonacci(n - 2); // 相同重复逻辑，缩小问题的规模
    }  </code></pre></li>
</ul>
</li>
</ul>
<p>对经典递归法的优化<br>斐波那契数列如下：<br>1,1,2,3,5,8,13,21,34,…<br>那么，我们可以这样看：fib(1,1,5) = fib(1,2,4) = fib(2,3,3) = 5<br>也就是说，以1,1开头的斐波那契数列的第五项正是以1,2开头的斐波那契数列的第四项，<br>而以1,2开头的斐波那契数列的第四项也正是以2,3开头的斐波那契数列的第三项，<br>更直接地，我们就可以一步到位：fib(2,3,3) = 2 + 3 = 5,计算结束。  </p>
<p>注意，前两个参数是数列的开头两项，第三个参数是我们想求的以前两个参数开头的数列的第几项。<br>时间复杂度：O(n)<br>@param first 数列的第一项<br>@param second 数列的第二项<br>@param n 目标项<br>@return  </p>
<pre><code>public static int optimizeFibonacci(int first, int second, int n) {
    if (n &gt; 0) {
        if(n == 1){    // 递归终止条件
            return first;       // 简单情景
        }else if(n == 2){            // 递归终止条件
            return second;      // 简单情景
        }else if (n == 3) {         // 递归终止条件
            return first + second;      // 简单情景
        }
        return optimizeFibonacci(second, first + second, n - 1);  // 相同重复逻辑，缩小问题规模
    }
    return -1;
}</code></pre><p>——————————–我是分割线————————————-</p>
<pre><code>/**
 * @description 非递归解法：有去无回
 * @author rico
 * @created 2017年5月10日 下午12:03:04
 * @param n
 * @return
 */
public static int fibonacci_loop(int n) {

    if (n == 1 || n == 2) {   
        return 1;
    }

    int result = -1;
    int first = 1;      // 自己维护的&quot;栈&quot;,以便状态回溯
    int second = 1;     // 自己维护的&quot;栈&quot;,以便状态回溯

    for (int i = 3; i &lt;= n; i++) { // 循环
        result = first + second;
        first = second;
        second = result;
    }
    return result;
}</code></pre><p>——————————–我是分割线————————————-</p>
<p>/**<br>     * @description 使用数组存储斐波那契数列<br>     * @author rico<br>     * @param n<br>     * @return<br>     */<br>    public static int fibonacci_array(int n) {<br>        if (n &gt; 0) {<br>            int[] arr = new int[n];   // 使用临时数组存储斐波纳契数列<br>            arr[0] = arr[1] = 1;</p>
<pre><code>        for (int i = 2; i &lt; n; i++) {   // 为临时数组赋值
            arr[i] = arr[i-1] + arr[i-2];
        }
        return arr[n - 1];
    }
    return -1;
}</code></pre><p>}<br>(3). 杨辉三角的取值</p>
<p>  @description 递归获取杨辉三角指定行、列(从0开始)的值</p>
<p>   @author rico<br>     @x  指定行<br>     @y  指定列    </p>
<pre><code>* Title: 杨辉三角形又称Pascal三角形，它的第i+1行是(a+b)i的展开式的系数。
* 它的一个重要性质是：三角形中的每个数字等于它两肩上的数字相加。
* 
* 例如，下面给出了杨辉三角形的前4行： 
*    1 
*   1 1
*  1 2 1
* 1 3 3 1
* @description 递归获取杨辉三角指定行、列(从0开始)的值
*              注意：与是否创建杨辉三角无关
* @author rico 
* @x  指定行
* @y  指定列  
*/
public static int getValue(int x, int y) {
    if(y &lt;= x &amp;&amp; y &gt;= 0){
        if(y == 0 || x == y){   // 递归终止条件
            return 1; 
        }else{ 
            // 递归调用，缩小问题的规模
            return getValue(x-1, y-1) + getValue(x-1, y); 
        }
    }
    return -1;
} </code></pre><p>(4). 回文字符串的判断  </p>
<ul>
<li><p>Title: 回文字符串的判断 </p>
</li>
<li><p>Description: 回文字符串就是正读倒读都一样的字符串。如”98789”, “abccba”都是回文字符串 </p>
</li>
<li></li>
<li><p>两种解法： </p>
</li>
<li><p>递归判断； </p>
</li>
<li><p>循环判断； </p>
<p>  public class PalindromeString {</p>
<pre><code>/**     
 * @description 递归判断一个字符串是否是回文字符串
 * @author rico       
 * @created 2017年5月10日 下午5:45:50     
 * @param s
 * @return     
 */
public static boolean isPalindromeString_recursive(String s){
    int start = 0;
    int end = s.length()-1;
    if(end &gt; start){   // 递归终止条件:两个指针相向移动，当start超过end时，完成判断
        if(s.charAt(start) != s.charAt(end)){
            return false;
        }else{
            // 递归调用，缩小问题的规模
            return isPalindromeString_recursive(s.substring(start+1).substring(0, end-1));
        }
    }
    return true;
}</code></pre><p>  ——————————–我是分割线————————————-</p>
<pre><code>/**     
 * @description 循环判断回文字符串
 * @author rico       
 * @param s
 * @return     
 */
public static boolean isPalindromeString_loop(String s){
    char[] str = s.toCharArray();
    int start = 0;
    int end = str.length-1;
    while(end &gt; start){  // 循环终止条件:两个指针相向移动，当start超过end时，完成判断
        if(str[end] != str[start]){
            return false;
        }else{
            end --;
            start ++;
        }
    }
    return true;
}</code></pre><p>  }</p>
</li>
</ul>
<p>(5). 字符串全排列<br>递归解法   </p>
<ul>
<li><p>@description 从字符串数组中每次选取一个元素，作为结果中的第一个元素;然后，对剩余的元素全排列</p>
</li>
<li><p>@author rico</p>
</li>
<li><p>@param s</p>
</li>
<li><p>字符数组</p>
</li>
<li><p>@param from</p>
</li>
<li><p>起始下标</p>
</li>
<li><p>@param to</p>
</li>
<li><p>终止下标</p>
<pre><code>public static void getStringPermutations3(char[] s, int from, int to) {
    if (s != null &amp;&amp; to &gt;= from &amp;&amp; to &lt; s.length &amp;&amp; from &gt;= 0) { // 边界条件检查
        if (from == to) { // 递归终止条件
            System.out.println(s); // 打印结果
        } else {
            for (int i = from; i &lt;= to; i++) {
                swap(s, i, from); // 交换前缀,作为结果中的第一个元素，然后对剩余的元素全排列
                getStringPermutations3(s, from + 1, to); // 递归调用，缩小问题的规模
                swap(s, from, i); // 换回前缀，复原字符数组
            }
        }
    }
}</code></pre></li>
</ul>
<ul>
<li><p>@description 对字符数组中的制定字符进行交换</p>
</li>
<li><p>@author rico</p>
</li>
<li><p>@param s</p>
</li>
<li><p>@param from</p>
</li>
<li><p>@param to</p>
<pre><code>public static void swap(char[] s, int from, int to) {
    char temp = s[from];
    s[from] = s[to];
    s[to] = temp;
}</code></pre></li>
</ul>
<p>非递归解法(字典序全排列)<br>/** </p>
<ul>
<li><p>Title: 字符串全排列非递归算法(字典序全排列) </p>
</li>
<li><p>Description: 字典序全排列，其基本思想是： </p>
</li>
<li><p>先对需要求排列的字符串进行字典排序，即得到全排列中最小的排列. </p>
</li>
<li><p>然后,找到一个比它大的最小的全排列，一直重复这一步直到找到最大值,即字典排序的逆序列. </p>
</li>
<li></li>
<li><p>不需要关心字符串长度 </p>
</li>
<li></li>
<li><p>@author rico </p>
</li>
<li><p>/   </p>
<p>   public class StringPermutationsLoop {<br>   **</p>
<pre><code>* @description 字典序全排列
* 
* 设一个字符串(字符数组)的全排列有n个，分别是A1,A2,A3,...,An
* 
* 1. 找到最小的排列 Ai
* 2. 找到一个比Ai大的最小的后继排列Ai+1
* 3. 重复上一步直到没有这样的后继
* 
* 重点就是如何找到一个排列的直接后继:
* 对于字符串(字符数组)a0a1a2……an,
* 1. 从an到a0寻找第一次出现的升序排列的两个字符(即ai &lt; ai+1),那么ai+1是一个极值，因为ai+1之后的字符为降序排列，记 top=i+1;
* 2. 从top处(包括top)开始查找比ai大的最小的值aj，记 minMax = j;
* 3. 交换minMax处和top-1处的字符;
* 4. 翻转top之后的字符(包括top)，即得到一个排列的直接后继排列
* 
* @author rico
    * @param s
    *            字符数组
    * @param from
    *            起始下标
    * @param to
    *            终止下标
    */
   public static void getStringPermutations4(char[] s, int from, int to) {

       Arrays.sort(s,from,to+1);  // 对字符数组的所有元素进行升序排列，即得到最小排列 
       System.out.println(s);    

       char[] descendArr = getMaxPermutation(s, from, to); // 得到最大排列,即最小排列的逆序列

       while (!Arrays.equals(s, descendArr)) {  // 循环终止条件：迭代至最大排列
           if (s != null &amp;&amp; to &gt;= from &amp;&amp; to &lt; s.length &amp;&amp; from &gt;= 0) { // 边界条件检查
               int top = getExtremum(s, from, to); // 找到序列的极值
               int minMax = getMinMax(s, top, to);  // 从top处(包括top)查找比s[top-1]大的最小值所在的位置
               swap(s, top - 1, minMax);  // 交换minMax处和top-1处的字符
               s = reverse(s, top, to);   // 翻转top之后的字符
               System.out.println(s);
           }
       }
   }

               @description 对字符数组中的制定字符进行交换
               public static void swap(char[] s, int from, int to) {
                   char temp = s[from];
                   s[from] = s[to];
                   s[to] = temp;
               }

            * @description 获取序列的极值
            * @author rico       
            * @param s 序列
            * @param from 起始下标
            * @param to 终止下标
           public static int getExtremum(char[] s, int from, int to) {
               int index = 0;
               for (int i = to; i &gt; from; i--) {
                   if (s[i] &gt; s[i - 1]) {
                       index = i;
                       break;
                   }
               }
               return index;
           }

   /**     
    * @description 从top处查找比s[top-1]大的最小值所在的位置
    * @author rico       
    * @created 2017年5月10日 上午9:21:13     
    * @param s
    * @param top 极大值所在位置
    * @param to
    * @return     
    */</code></pre></li>
</ul>
<pre><code>        public static int getMinMax(char[] s, int top, int to) {
            int index = top;
            char base = s[top-1];
            char temp = s[top];
            for (int i = top + 1; i &lt;= to; i++) {
                if (s[i] &gt; base &amp;&amp; s[i] &lt; temp) {
                    temp = s[i];
                    index = i;
                }
                continue;
            }
            return index;
        }

/**     
 * @description 翻转top(包括top)后的序列
 * @author rico       
 * @param s
 * @param from
 * @param to
 * @return     
 */



            public static char[] reverse(char[] s, int top, int to) {
                char temp;
                while(top &lt; to){
                    temp = s[top];
                    s[top] = s[to];
                    s[to] = temp;
                    top ++;
                    to --;
                }
                return s;
            }

/**     
 * @description 根据最小排列得到最大排列
 * @author rico       
 * @param s 最小排列
 * @param from 起始下标
 * @param to 终止下标
 * @return     
 */    


        public static char[] getMaxPermutation(char[] s, int from, int to) {
            //将最小排列复制到一个新的数组中
            char[] dsc = Arrays.copyOfRange(s, 0, s.length);
            int first = from;
            int end = to;
            while(end &gt; first){  // 循环终止条件
                char temp = dsc[first];
                dsc[first] = dsc[end];
                dsc[end] = temp;
                first ++;
                end --;
            }
            return dsc;
        }</code></pre><p>(6). 二分查找<br>/** </p>
<ul>
<li>@description 二分查找的递归实现 </li>
<li>@author rico </li>
<li>@param array 目标数组 </li>
<li>@param low 左边界 </li>
<li>@param high 右边界 </li>
<li>@param target 目标值 </li>
<li>@return 目标值所在位置 </li>
<li>/</li>
</ul>
<pre><code>public static int binarySearch(int[] array, int low, int high, int target) {
    //递归终止条件
    if(low &lt;= high){
        int mid = (low + high) &gt;&gt; 1;
        if(array[mid] == target){
            return mid + 1;  // 返回目标值的位置，从1开始
        }else if(array[mid] &gt; target){
            // 由于array[mid]不是目标值，因此再次递归搜索时，可以将其排除
            return binarySearch(array, low, mid-1, target);
        }else{
            // 由于array[mid]不是目标值，因此再次递归搜索时，可以将其排除
            return binarySearch(array, mid+1, high, target);
        }
    }
    return -1;   //表示没有搜索到
}</code></pre><p>——————————–我是分割线————————————-</p>
<p>/**<br>     * @description 二分查找的非递归实现<br>     * @author rico<br>     * @param array 目标数组<br>     * @param low 左边界<br>     * @param high 右边界<br>     * @param target 目标值<br>     * @return 目标值所在位置<br>     */</p>
<pre><code>public static int binarySearchNoRecursive(int[] array, int low, int high, int target) 
{
    // 循环
    while (low &lt;= high) {
        int mid = (low + high) &gt;&gt; 1;
        if (array[mid] == target) {
            return mid + 1; // 返回目标值的位置，从1开始
        } else if (array[mid] &gt; target) {
            // 由于array[mid]不是目标值，因此再次递归搜索时，可以将其排除
            high = mid -1;
        } else {
            // 由于array[mid]不是目标值，因此再次递归搜索时，可以将其排除
            low = mid + 1;
        }
    }
    return -1;  //表示没有搜索到
}</code></pre><ol>
<li>第二类问题：问题解法按递归算法实现<br>(1). 汉诺塔问题<br>/**   </li>
</ol>
<ul>
<li>Title: 汉诺塔问题     </li>
<li>Description:古代有一个梵塔，塔内有三个座A、B、C，A座上有64个盘子，盘子大小不等，大的在下，小的在上。    </li>
<li>有一个和尚想把这64个盘子从A座移到C座，但每次只能允许移动一个盘子，并且在移动过程中，3个座上的盘子始终保持大盘在下，     </li>
<li>小盘在上。在移动过程中可以利用B座。要求输入层数，运算后输出每步是如何移动的。    </li>
<li></li>
</ul>

      
      <!-- reward -->
      
      <div id="reward-btn">
        打赏
      </div>
      
    </div>
    
    
      <!-- copyright -->
      
        <div class="declare">
          <ul class="post-copyright">
            <li>
              <i class="ri-copyright-line"></i>
              <strong>版权声明： </strong>
              本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
            </li>
          </ul>
        </div>
        
    <footer class="article-footer">
      
          
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://yoursite.com/2020/04/27/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%A8%B3%E5%9B%BA-%E9%80%92%E5%BD%92/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%92%E5%BD%92/" rel="tag">递归</a></li></ul>


    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="/2020/04/27/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E7%A8%B3%E5%9B%BA-%E6%8E%92%E5%BA%8F/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            基础算法稳固-排序
          
        </div>
      </a>
    
    
      <a href="/2020/04/27/%E5%89%91%E6%8C%87OFFER/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">剑指未来</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        app_id: 'bbpQw161m67zfpKoIaX0DjRP-gzGzoHsz',
        app_key: '1OB4hLIBzNt40C7AAQ3ImBWG',
        path: window.location.pathname,
        notify: 'false',
        verify: 'false',
        avatar: 'monsterid',
        placeholder: '给我的文章加点评论吧~',
        recordIP: true
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
  
  
  
  
<!-- minivaline评论 -->
<div id="mvcomments-box">
    <div id="mvcomments">
    </div>
</div>
<script src='https://cdn.jsdelivr.net/npm/minivaline/dist/MiniValine.min.js'></script>
<script>
	new MiniValine({
	  el: '#mvcomments',
	  appId: 'bbpQw161m67zfpKoIaX0DjRP-gzGzoHsz',
	  appKey: '1OB4hLIBzNt40C7AAQ3ImBWG',
	  placeholder: 'Write a Comment',
	  lang: '',
	  adminEmailMd5: '',
	  math: true,
	  md: true
	});
    const infoEle = document.querySelector('#mvcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #mvcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #mvcomments-box {
            padding: 5px 0px;
        }
    }

    #mvcomments-box #mvcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2020
        <i class="ri-heart-fill heart_icon"></i> Chen Bin
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="梦想岛"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">算法与程序设计</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E4%BB%A3%E7%A0%81%E8%AF%B4/">代码说</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="http://chenbin-vip.lofter.com" target="_blank" rel="noopener">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E5%A4%96%E8%AF%AD%E5%AD%A6%E4%B9%A0/">外语学习</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84/">法律法规</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/about/">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://i.loli.net/2020/04/24/VjamHOiTgk26EpK.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://i.loli.net/2020/04/24/FMJN75HGXRpDdP4.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Subtitle -->

<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
      startDelay: 0,
      typeSpeed: 180,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
    console.log(err)
  }
</script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>

<!-- Katex -->


    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css">
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"></script>
        
    


<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->


<script src="/js/clickLove.js"></script>


<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>



    
  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

</html>