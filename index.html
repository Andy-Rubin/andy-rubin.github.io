<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="学习，生活，思考，代码，博客" />
   
  <meta name="description" content="梦想的萌生岛" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     梦想岛
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

<link rel="alternate" href="/atom.xml" title="梦想岛" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Andy-Rubin/andy-rubin.github.io"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover6.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">梦想岛</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-数据库" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/08/18/%E6%95%B0%E6%8D%AE%E5%BA%93/"
    >数据库</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/08/18/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="article-date">
  <time datetime="2020-08-18T02:41:59.000Z" itemprop="datePublished">2020-08-18</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h4><p>数据库管理系统（DBMS）：有一个相互关联的数据的集合和一组用于访问这些数据的程序组成。这个数据集合通常称作数据库，其中包含了关于某个企业的信息。其主要目标是要提供一种可以方便、高效地存取数据库信息的途径。</p>
<p>传统的文件处理系统存在很多弊端：</p>
<p>数据的冗余和不一致；数据访问困难；数据孤立；完整性问题；</p>
<p>原子性问题：比如银行系统中借和贷，从A中取出500，放进B账户时，系统故障，恢复后可能会A中没了500，但是B中没有多500。如同任何别的设备一样，计算机系统也会发生故障，一旦故障发生，数据就应被恢复到故障发生以前的一致的状态，对很多应用来说，这样的保证是至关重要的。显然，为了数据库一致性，这里借和贷两个操作必须是要么发生，要么都不发生。也就是说转账必须是原子的——它要么全部发生要么根本不发生。</p>
<p>并发访问异常；安全性问题；</p>
<h4 id="数据视图"><a href="#数据视图" class="headerlink" title="数据视图"></a><strong>数据视图</strong></h4><p>数据库系统是一些相互关联的数据以及一组使得用户可以访问和修改这些数据的程序的集合。数据库系统的一个主要目的是给用户提供数据的抽象视图，即系统隐藏关于数据存储和维护的某些细节。</p>
<h5 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a><strong>数据抽象</strong></h5><p>一个可用的系统必须能高效地检索数据。这种高效性的需求促使设计者在数据库中使用复杂的数据结构表示数据。而用户不能直接懂这些专业知识，这就需要开发人员对一下几层，用户屏蔽复杂性，简化交互：</p>
<ul>
<li><strong>物理层</strong></li>
</ul>
<p>最低层次的抽象，描述数据实际上是怎样存储的。物理层详细描述复杂的底层数据结构。</p>
<ul>
<li><strong>逻辑层</strong></li>
</ul>
<p>比物理层层次稍高的抽象，描述数据库中存储什么数据及这些数据间存在什么关系。这样逻辑层就通过少量相对简单的结构描述了整个数据库。虽然逻辑层的简单结构的实现可能涉及复杂的物理层结构，但逻辑层的用户不必知道这样的复杂性。这称作物理数据独立性。数据库管理员使用抽象的逻辑层，他必须确定数据库中应该保存哪些信息。</p>
<ul>
<li><strong>视图层</strong></li>
</ul>
<p>最高层次的抽象，只描述整个数据库的某个部分。尽管在逻辑层使用了比较简答的结构，但由于一个大型数据库中所存储的信息的多样性，仍存在一定程度的复杂性。数据库系统的很多用户并不需要关系所有的信息，而只需要访问数据库的一部分。视图层抽象的定义正是为了使这样的用户与系统的交互更简单。系统可以同一数据库提供多个视图。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type instructor = recode</span><br><span class="line">	ID: char(5);</span><br><span class="line">	name:char(20);</span><br><span class="line">	dept_name:char(20);</span><br><span class="line">	salary:numeric(8,2);</span><br><span class="line">	<span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<p>以上代码定义了一个具有四个字段的新纪录</p>
<p>在物理层，一个instrutor记录可能被描述为连续存储位置组成的存储块。</p>
<p>在逻辑层，，每个这样的记录通过类型定义进行描述。在逻辑层上同时还要定义这些记录类型的相互关系。程序设计人员正是这个抽象层次上使用程序语言进行工作。</p>
<p>在视图层，计算机用户看见的是为其屏蔽了数据类型细节的一组应用程序。</p>
<p><strong>过程化数据操作语言：</strong></p>
<p>它使得用户可以访问或操纵哪些按照某种适当的数据模型组织起来的数据。以下访问类型：</p>
<ul>
<li>对存储在数据库中的信息进行检索</li>
<li>从数据库中删除信息</li>
<li>向数据库中插入新的信息</li>
<li>修改数据库中存储的信息</li>
</ul>
<p><strong>关系数据库</strong></p>
<p>关系数据库基于关系模型，使用一系列来表达数据以及这些数据之间的联系。关系数据库也包括DML（过程化数据操作语言）和DDL（数据定义语言）</p>
<p>instructor</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>NAME</th>
<th>DEPT_NAME</th>
<th>SALARY</th>
</tr>
</thead>
<tbody><tr>
<td>12121</td>
<td>WU</td>
<td>HISTORY</td>
<td>60000</td>
</tr>
</tbody></table>
<p>department</p>
<table>
<thead>
<tr>
<th>DEPT_NAME</th>
<th>BUILDING</th>
<th>BUDGET</th>
</tr>
</thead>
<tbody><tr>
<td>Music</td>
<td>Packard</td>
<td>80000</td>
</tr>
</tbody></table>
<h4 id="表"><a href="#表" class="headerlink" title="表"></a>表</h4><p> 每个表有很多列，每个列有唯一的名字。比如instructor表，表示，ID为12121的WU老师，是物理系成员，工资60000.</p>
<p>关系模型是基于记录的模型的一个实例。基于记录的模型，之所以有次称谓，因为数据库的结构是几种固定格式的记录。每个表包含一种特定类型的记录。每种记录类型定义固定数目的字段或属性。表的列对应记录类型的属性。</p>
<h4 id="数据操纵语言"><a href="#数据操纵语言" class="headerlink" title="数据操纵语言"></a><strong>数据操纵语言</strong></h4><p>SQL查询语言是非过程化的。它以几个表作为输入，总是仅返回一个表。例如：找出历史系的所有教员的名字：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> instruct.name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> instructor.dept_name=<span class="string">'History'</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个查询指定了从instrcut表中，要取回的是dept_name为History的那些行，并且这些行的name属性要显示出来。更具体点，执行本查询的结果是一个表，它有一列name和若干行，每一行都是dept_name为History的一个老师的名字。</p>
</blockquote>
<p>查询可以涉及来自不止一个表的信息。下面将找出经费超过95000的系相关的所有教员的ID和系名。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> instructor.ID, department.dept_name</span><br><span class="line"><span class="keyword">from</span> instruct, department</span><br><span class="line"><span class="keyword">where</span> instructor.dept_name=departname.dept_name <span class="keyword">and</span> department.budget &gt; <span class="number">95000</span>;</span><br></pre></td></tr></table></figure>

<h4 id="数据定义语言"><a href="#数据定义语言" class="headerlink" title="数据定义语言"></a><strong>数据定义语言</strong></h4><p>SQL提供了一个丰富的DDL语言，通过它，我们可以定义表、完整性约束、断言，等。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> tabel department</span><br><span class="line">	(dept_name <span class="built_in">char</span>(<span class="number">20</span>),</span><br><span class="line">    building <span class="built_in">char</span>(<span class="number">15</span>),</span><br><span class="line">    budget <span class="built_in">numeric</span>(<span class="number">12</span>,<span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<h4 id="实体-联系模型"><a href="#实体-联系模型" class="headerlink" title="实体-联系模型"></a><strong>实体-联系模型</strong></h4><p>实体-联系(E-R)数据模型使用一组称作实体的基本对象，以及这些对象间的联系。实体是现实世界中可区别于其他对象的一件“事情”或一个“物体”。</p>
<p>数据库中实体通过“<strong>属性</strong>”集合来描述。例如ID,name和salary.</p>
<p>联系是几个实体之间的关联。例如,member联系将一位教师和她所在的系关联在一起。同一类型的所有实体的集合称作<strong>实体集</strong>，同一类型的所有联系的集合称作<strong>联系集</strong>。</p>
<p>数据库的总体逻辑结构（模式）可以用实体-联系图进行图形化表示。有几种方法来画这样的图。最常用的方法之一是采用统一建模语言（UML）。</p>
<ul>
<li><p>实体集用矩形表示，实体名在头部，属性名列在下面</p>
</li>
<li><p>联系集用连接一对相关的实体集的菱形表示，联系名在菱形里。</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200818145549679.png" alt="image-20200818145549679"></p>
</li>
</ul>
<p>除了实体和联系外，E-R模型还描述了数据库必须遵守的对其内容的某些约束。一个重要的约束是<strong>映射基数</strong>。它表示通过某个联系集能与一实体进行关联的实体数目。</p>
<h4 id="数据存储和查询"><a href="#数据存储和查询" class="headerlink" title="数据存储和查询"></a><strong>数据存储和查询</strong></h4><p>数据库系统划分为不同的模块，每个模块完成</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  
  
  

</article>
    
    <article id="post-回溯算法" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/08/17/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"
    >回溯算法</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/08/17/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2020-08-17T08:05:02.000Z" itemprop="datePublished">2020-08-17</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;(); </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 主函数，输入一组不重复的数字，返回它们的全排列 */</span> </span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;    </span><br><span class="line">    <span class="comment">// 记录「路径」    </span></span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();    </span><br><span class="line">    backtrack(nums, track);    </span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径：记录在 track 中 </span></span><br><span class="line"><span class="comment">// 选择列表：nums 中不存在于 track 的那些元素 </span></span><br><span class="line"><span class="comment">// 结束条件：nums 中的元素全都在 track 中出现 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span> </span>&#123;    </span><br><span class="line">    <span class="comment">// 触发结束条件    </span></span><br><span class="line">    <span class="keyword">if</span> (track.size() == nums.length) &#123;        </span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList(track));        </span><br><span class="line">        <span class="keyword">return</span>;    </span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) </span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="comment">// 排除不合法的选择       </span></span><br><span class="line">        <span class="keyword">if</span> (track.contains(nums[i]))            </span><br><span class="line">            <span class="keyword">continue</span>;  </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 做选择        </span></span><br><span class="line">        track.add(nums[i]);  </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 进入下一层决策树        </span></span><br><span class="line">        backtrack(nums, track); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 取消选择        </span></span><br><span class="line">        track.removeLast();    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  
  
  

</article>
    
    <article id="post-ANDROID-0" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/24/ANDROID-0/"
    >ANDROID</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/07/24/ANDROID-0/" class="article-date">
  <time datetime="2020-07-24T12:18:10.000Z" itemprop="datePublished">2020-07-24</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h2 id="Android说"><a href="#Android说" class="headerlink" title="Android说"></a><strong>Android说</strong></h2><p><strong>res目录</strong></p>
<p>存放Android项目的各种资源，比如layout,存放界面布局文件；values目录下则存放各种XML格式的资源文件，例如字符串资源文件：string.xml；颜色资源文件：colors.xml;尺寸资源文件：dimens.xml，drawable-ldpi,drawable-mdpi,drawable-hdpi,drawable-xhdpi这个4个子目录则分别用于存放分辨率、中分辨率、高分辨路、超高分辨率的4中图片文件。</p>
<hr>
<p>res目录是一个特殊的项目，里面存放了Android应用所用的全部资源，包括图片资源、字符串资源、颜色资源、尺寸资源等。</p>
<p>按照约定，将不同的资源放在不同的文件夹内，这样可以方便地让aapt工具来扫描这些资源，并未它们生成对应的资源清单类：R.java</p>
<p>例子： res/value/string.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"app_name"</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面资源文件中定义了一个字符串常量，常量的值为HelloWorld,一旦定义了这份字符串常量，Android项目就允许分别在java代码、XML文件中使用这份资源文件中的字符串资源。</p>
<p><strong>1.在Java代码中使用资源</strong></p>
<p>为了在Java代码中使用资源，AAPT会为Android项目自动生成一份R.java文件，R类里为每份资源分别定义了一个内部类，其中每个资源项对应于内部类里一个Int类型的Field。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> app_name=<span class="number">0x7f040000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>借助于AAPT自动生成R类的帮助，在JAVA代码中通过R.string.app_name引用到“Hello World”字符串常量。</p>
<p><strong>2.在xml文件中使用资源</strong></p>
<p>在XML文件中使用资源更加简单，只要按照如下格式来访问即可</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="tag">&lt;<span class="name">资源对应的内部类的类名</span>&gt;</span>/<span class="tag">&lt;<span class="name">资源项的名称</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>比如我们要访问上面的字符串资源中定义的“HelloWorld”字符串常量，则使用如下形式引用：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@string/app_name</span><br></pre></td></tr></table></figure>

<p>还有一种情况：为该组件分配标识符</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@+id/<span class="tag">&lt;<span class="name">标识符代号</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:id="@+id/ok"</span><br></pre></td></tr></table></figure>

<p>接下来就可以在程序中引用该组件。</p>
<p>如果在Java中获取该组件，通过调用Activity的findViewById()方法即可实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@id&#x2F;&lt;标识符代号&gt;</span><br></pre></td></tr></table></figure>

<p><strong>src目录</strong></p>
<p>只是一个普通的、保存Java源文件的目录。</p>
<p><strong>AndroidManifest.xml</strong></p>
<p>文件时Android项目的系统清单文件，它用于控制Android应用的名称、图标、访问权限等整体属性。除此之外，Android应用的Activity、Service、ContentProvider、BroadcastReceiver这4大组件都需要在该文件中配置。</p>
<p><strong>gen目录</strong></p>
<p>用于保存自动生成的、位于Android项目包下的R.java文件。R.java可以理解成Android应用的资源字典。</p>
<p>AAPT:</p>
<p>aapt即Android Asset Packaging Tool，在SDK的build-tools目录下。该工具可以查看，创建， 更新ZIP格式的文档附件(zip, jar, apk)。也可将资源文件编译成<a href="https://baike.so.com/doc/6848461-7065887.html" target="_blank" rel="noopener">二进制文件</a>，尽管你可能没有直接使用过aapt工具，但是build scripts和IDE<a href="https://baike.so.com/doc/1483288-1568456.html" target="_blank" rel="noopener">插件</a>会使用这个工具打包apk文件构成一个Android 应用程序。在使用aapt之前需要在环境变量里面配置SDK-tools路径，或者是路径+aapt的方式进入aapt。</p>
<p>AAPT生成R.java文件的规则主要是如下两条：</p>
<ul>
<li>每类资源都对应于R类的一个内部类。比如所有界面布局资源对应于layout内部类；所有字符串资源对应于string内部类；所有标识符资源对应于id内部类；</li>
<li>每个具体的资源项都对应于内部类的一个public staitc final int类型的Field。</li>
</ul>
<p><strong>bin目录</strong></p>
<p>该目录用于存放生成的目标文件，如Java的二进制文件、资源打包文件（.ap_后缀），Dalvik虚拟机的可执行性文件（.dex后缀）等</p>
<hr>
<p><strong>AnndroidManifest.xml ： Android应用清单文件</strong></p>
<p>是整个Android应用的全局描述文件，说明了该应用的名称，所使用的图标以及包含的组件等。</p>
<p>包含信息如下：</p>
<ul>
<li>应用程序的包名，该包名将会作为该应用的唯一标识</li>
<li>应用程序所包含的组件，如Activity,Service,BroadcastReceiver和ContentProvider等</li>
<li>应用程序兼容的最低版本</li>
<li>应用程序使用系统所需的权限声明</li>
<li>其他程序访问该程序所需的权限声明</li>
</ul>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200725210654538.png" alt="image-20200725210654538"></p>
<p>Android应用基本组件</p>
<h2 id="1-Activity"><a href="#1-Activity" class="headerlink" title="1.Activity"></a><strong>1.Activity</strong></h2><p>Activity是Android应用中负责与用户交互的组件——大致上可以想象成Swing编程中的JFrame组件。区别就是：JFrame本身可以设置布局管理器，不断地向JFrame中添加组件，但Activity只能通过setContentView(view)来显示指定的组件。</p>
<p>View组件是所有UI控件、容器控件的基类，View组件就是Android应用中用户实实在在看到部分。但View组件需要放到容器组件中，或者使用Activity将它显示出来。如果需要通过某个Activity把指定View显示出来，调用Activity的setContentView()方法即可。</p>
<p>setContentView()方法可接收一个View对象作为参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个线性布局管理器</span></span><br><span class="line">LinearLayout layout = <span class="keyword">new</span> LinearLayout(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//设置该Activity显示layout</span></span><br><span class="line">setContentView(layout);</span><br></pre></td></tr></table></figure>

<p>setContentView()方法也接受一个布局管理资源的ID作为参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置该Activity显示main.xml文件定义的View</span></span><br><span class="line">setContentView(R.layout.main);</span><br></pre></td></tr></table></figure>

<h2 id="2-Service"><a href="#2-Service" class="headerlink" title="2.Service"></a><strong>2.Service</strong></h2><p>​       Service与Activity的地位是并列的，他也代表一个单独的Android组件。Service与Activity区别在于它一直在后台运行，一般不需要与用户交互，因此Service组件没有图像用户界面。</p>
<p>​       和Activity组件需要继承Activity基类相似，Service组件需要继承Service基类。一个Service组件被运行起来之后，他将拥有自己独立的生命周期，Service组件通常用于为其他组件提供后台服务或者监控其它组件的运行状态。</p>
<h2 id="3-BroadcastReceiver"><a href="#3-BroadcastReceiver" class="headerlink" title="3.BroadcastReceiver"></a><strong>3.BroadcastReceiver</strong></h2><p>是Android应用中另一个重要的组件，BroadcastReceiver代表广播消息接收器。从代码实现角度看，BroacastReceiver非常类似于事件编程中的监听器。与普通事件监听器不同的是，普通事件监听器监听的事件源是程序中的对象；而BroadcastReceiver监听的事件源是Android应用中的其他组件。</p>
<p>使用BroadcastReceiver组件接收广播消息比较简单，开发者只要实现自己的BroadcastReceiver子类，并重写onReceive(Context context, Intent intent)方法即可。当其他组件通过sendBroadcast()、sendStickyBroadcast()或sendOrderedBroad()方法发送广播消息时，如果该BroadcastReceiver也对该消息“感兴趣”（通过IntentFilter配置），BroadcastReceiver的onReceive（Context context, Intent intent）方法将会被触发。</p>
<p>开发者实现了自己的BroadcastReceiver之后，通常有两种方法来注册这个系统级的“事件监听器”</p>
<ul>
<li>在Java代码中通过Context.registReceiver()方法注册BroadcastReceiver</li>
<li>在AndroidManifest.xml文件中使用&lt;reciever…/&gt;元素完成注册。</li>
</ul>
<h2 id="4-ContentProvider"><a href="#4-ContentProvider" class="headerlink" title="4.ContentProvider"></a><strong>4.ContentProvider</strong></h2><p>Android会有各个应用程序之间交换数据的时候，Android系统为这种跨应用的数据交换提供了一个标准：ContentProvider。当用户实现自己ContentProvider时，需要实现如下抽象方法：</p>
<ul>
<li>insert(Uri, ContentValues):向ContentProvider插入数据。</li>
<li>delete(Uri,ContentValues)：删除ContentProvider中指定数据</li>
<li>updata(Uri,ContentValues,String, String[]) ：更新ContentProvider中指定数据</li>
<li>query(Uri,String[], String,String[],String):从ContentProvider查询数据。</li>
</ul>
<p>通常与ContentProvider结合使用的是ContentResolver,一个应用程序使用ContentProvider暴露自己的数据，而另一个应用程序则通过ContentResolver来访问数据。</p>
<h3 id="使用Android-Studio-对-Android应用签名"><a href="#使用Android-Studio-对-Android应用签名" class="headerlink" title="使用Android Studio 对 Android应用签名"></a><strong>使用Android Studio 对 Android应用签名</strong></h3><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200729153412733.png" alt="image-20200729153412733"></p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200729153504203.png" alt="image-20200729153504203"></p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200729153541663.png" alt="image-20200729153541663"></p>
<p>如果有私密玥要文件就用有的再输入密码就可以。没有就接着看：</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200729154113853.png" alt="image-20200729154113853"></p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200729154128210.png" alt="image-20200729154128210"></p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200729154335791.png" alt="image-20200729154335791"></p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200729154440350.png" alt="image-20200729154440350"></p>
<p>有时候新建Android工程会缺少R.java文件，就需要在</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200729165710922.png" alt="image-20200729165710922"></p>
<p>这里勾上Build Auto….</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  
  
  

</article>
    
    <article id="post-C-的头文件" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/20/C-%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6/"
    >C++的头文件</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/07/20/C-%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6/" class="article-date">
  <time datetime="2020-07-20T02:04:01.000Z" itemprop="datePublished">2020-07-20</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h2 id="C-的头文件细说"><a href="#C-的头文件细说" class="headerlink" title="C++的头文件细说"></a><strong>C++的头文件细说</strong></h2><h3 id="unistd-h"><a href="#unistd-h" class="headerlink" title="unistd.h"></a><strong>unistd.h</strong></h3><p>提供对POSIX操作系统API的访问功能，其中调用的接口大量都是对系统调用的封装。</p>
<blockquote>
<p>引申：    POSIX（Portable Operating System Interface of UNIX, POSIX）表示可移植操作系统接口，POSIX标准定义了操作系统应该为应用程序提供的接口标准，是IEEE为要在各种UNIX操作系统上运行的软件定义的一系列API标准的总称。</p>
<p>主流操作系统有两种，一种是Window系统，另一种是LINUX系统，由于系统不同，API又分为WINDOWS API和Linux API。两者在各自平台上开发出来的软件就无法在对方上运行，导致软件移植困难，POSIX（可移植操作系统规范）应运而生。</p>
<p>linux和Windows都要实现基本的posix标准，linux把fork函数封装成posix_fork（随便说的），windows把creatprocess也封装成posix_fork，都声明在unistd.h里。这样，程序员在编写普通应用的时候，只用包含unistd.h，调用posix_fork函数，程序就在源代码级别可移植了。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fork()  <span class="comment">//复制进程</span></span><br><span class="line">pipe()  <span class="comment">//管道，即把两个进程之间的标准输入和标准输出连接起来的机制，从而提供一种让多个进程间通信的方法</span></span><br></pre></td></tr></table></figure>

<h3 id="arpa-inet-h"><a href="#arpa-inet-h" class="headerlink" title="arpa/inet.h"></a><strong>arpa/inet.h</strong></h3><p>定义了更多的网络类型和函数（包含netline/in.h）,如inet_addr,inet_aton等</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  
  
  

</article>
    
    <article id="post-TCP-IP网络编程" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/20/TCP-IP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"
    >TCP/IP网络编程</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/07/20/TCP-IP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="article-date">
  <time datetime="2020-07-20T01:25:50.000Z" itemprop="datePublished">2020-07-20</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h2 id="TCP-IP网络编程"><a href="#TCP-IP网络编程" class="headerlink" title="TCP/IP网络编程"></a><strong>TCP/IP网络编程</strong></h2><p><strong>构建电话套接字</strong></p>
<p>套接字一般分两种，TCP套接字可以比喻成电话机，电话机可以同时拨打或接听，但对套接字而言拨打和接听是有区别的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>

<p>上面函数就是相当于电话机的套接字。</p>
<p>准备好电话机（预定义了套接字，以后可以直接用）就需要考虑分配电话号码的问题，这样别人才能联系到自己。</p>
<p><strong>调用bind函数（分配电话号码）时进行的对话</strong></p>
<p>利用下面的函数给创建好的套接字分配地址信息（IP地址和端口号）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *myaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>; </span><br><span class="line"><span class="comment">//成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure>

<p>调用bind函数给套接字分配地址后，就基本完成了接电话的所有准备工作。接下来需要连接电话线并等待来电。（相当于知道了电话号码了）</p>
<p><strong>调用listen函数（连接电话线）时进行的对话</strong></p>
<p>​       一连接电话线，电话机就转为可接听状态，这时其他人可以拨打电话请求连接到该机。同样，需要把套接字转化成可接收连接的状态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>

<p>连接好电话线，如果有人拨打，需要拿起话筒才能接听电话。</p>
<p><strong>调用accept函数（拿起话筒）时进行的对话</strong></p>
<p>拿起话筒意味着接收了对方的连接请求。套接字同样如此，如果有人为了完成数据传输而请求连接，就需要调用以下函数进行受理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="网络编程中接受连接请求的套接字创建过程可整理如下："><a href="#网络编程中接受连接请求的套接字创建过程可整理如下：" class="headerlink" title="网络编程中接受连接请求的套接字创建过程可整理如下："></a><strong>网络编程中接受连接请求的套接字创建过程可整理如下：</strong></h3><ul>
<li>第一步：调用socket函数<strong>创建套接字</strong></li>
<li>第二步：调用bind函数<strong>分配IP地址和端口号</strong></li>
<li>第三部：调用listen函数转为可接收请求状态</li>
<li>第四部：调用accept函数受理连接请求。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hello_server.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> serve_sock;</span><br><span class="line">    <span class="keyword">int</span> clnt_sock;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clnt_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clnt_addr_size;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> message[]=<span class="string">"Hello World!"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage : %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    serv_sock=sock(PE_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(serv_sock == <span class="number">-1</span>)&#123;</span><br><span class="line">        error_handling(<span class="string">"socket() error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sinfamily = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(bind(serv_sock, (struck sockaddr*) &amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr))==<span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"bind() error"</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">listen</span>(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"listen() error"</span>);</span><br><span class="line">    clnt_addr_size=<span class="keyword">sizeof</span>(clnt_addr);</span><br><span class="line">    clnt_sock = accept(serv_sock, (struct sockaddr*)&amp;clnt_addr, &amp;clnt_addr_size);</span><br><span class="line">    <span class="keyword">if</span>(clnt_sock == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"accept() error"</span>);</span><br><span class="line">    <span class="built_in">write</span>(clnt_sock, message, <span class="keyword">sizeof</span>(message));</span><br><span class="line">    <span class="built_in">close</span>(clnt_sock);</span><br><span class="line">    <span class="built_in">close</span>(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">'\n'</span>,<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构建打电话套接字"><a href="#构建打电话套接字" class="headerlink" title="构建打电话套接字"></a><strong>构建打电话套接字</strong></h3><p>服务器端创建的套接字又称为服务器套接字或监听（listening）套接字。接下来介绍的套接字是用于请求连接的客户端套接字。客户端套接字的创建过程比创建服务器端套接字简单。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *serv_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hello_client.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa.inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> message[<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">int</span> str_len;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Usage : %s &lt;IP&gt;&lt;port&gt; \n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sock = socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sock == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"socket() error"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family=AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_add = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_addr.sin_port=htons(atoi[<span class="number">2</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">connect</span>(sock, (struct sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr))==<span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"connect()) error!"</span>);</span><br><span class="line">    str_len = <span class="built_in">read</span>(sock, message, <span class="keyword">sizeof</span>(message)<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(str_len==<span class="number">-1</span>)&#123;</span><br><span class="line">        error_handling(<span class="string">"read() error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Message from server : %s \n"</span>, message);</span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(messagem <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">'\n'</span>,<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>












      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  
  
  

</article>
    
    <article id="post-工程说" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/10/%E5%B7%A5%E7%A8%8B%E8%AF%B4/"
    >工程说</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/07/10/%E5%B7%A5%E7%A8%8B%E8%AF%B4/" class="article-date">
  <time datetime="2020-07-10T02:19:01.000Z" itemprop="datePublished">2020-07-10</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(n)         <span class="comment">//作用：C编译器将按照n个字节对齐</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()          <span class="comment">//作用：取消自定义字节对齐方式</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push,1)    <span class="comment">//作用：是指把原来对齐方式设置压栈，并设新的对齐方式设置为一个字节对齐</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)       <span class="comment">//作用：恢复对齐状态</span></span></span><br><span class="line"></span><br><span class="line">加入push和pop可以使对齐恢复到原来状态，而不是编译器默认，可以说后者更优，但是很多时候两者差别不大</span><br><span class="line">    </span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push)      <span class="comment">//保存对齐状态</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)         <span class="comment">//设定为4字节对齐     相当于  #pragma pack(push,4)</span></span></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1)         <span class="comment">//作用：调整结构体的边界对齐，让其以一个字节对齐；</span></span></span><br><span class="line">&lt;结构体按<span class="number">1</span>字节方式对齐&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">    </span><br><span class="line">例如：    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br><span class="line">--------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>应用实例</p>
<p>在网络协议编程中，经常会处理不同协议的数据报文。一种方法是通过指针偏移的方法得到各种信息，但这样做不仅编程复杂，而且一旦协议变化，程序修改起来比较麻烦。在了解编译器对结构空间的分配原则后，我们完全可以利用这一特性定义自己的协议结构，通过访问结构的成员来获取各种信息。</p>
<p>下面以TCP协议首部为例，说明如何定义协议结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#pragma pack(1)     &#x2F;&#x2F;按照1字节进行对齐</span><br><span class="line"></span><br><span class="line">struck TCPHEADER&#123;</span><br><span class="line">	short SrcPort; &#x2F;&#x2F;16位源端口号</span><br><span class="line">	short DstPort; &#x2F;&#x2F;16位目的端口号</span><br><span class="line">	int SeriaNo;   &#x2F;&#x2F;32位序列号</span><br><span class="line">	int AckNO;     &#x2F;&#x2F;32位确认号</span><br><span class="line">	unsigned char  HaderLen : 4;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="用结构体实现位段"><a href="#用结构体实现位段" class="headerlink" title="用结构体实现位段"></a><strong>用结构体实现位段</strong></h2><p>位段作用:位段是在字段的声明后面加一个冒号以及一个表示字段位长的整数来实现。这种用法又被叫：深入逻辑元件的编程。</p>
<p>使用位段理由：1.他能把长度为奇数的数据包装在一起，从而节省存储的空间；2.他可以很方便地访问一个整型值得部分内容。</p>
<blockquote>
<p>注意：</p>
<ul>
<li>位段成员只有三种类型：int, unsigned int 和 signed int这三种；</li>
<li>成员名后面的一个冒号和一个整数，这个整数指定该位段的位长(bit);</li>
<li>许多编译器把位段成员的字长限制在一个int的长度范围之内；</li>
<li>位段成员在内存的实现是从左到右还是从右到左是由编译器来决定的，但二者皆对。</li>
</ul>
</blockquote>
<p>磁盘控制器用于和软驱通信，下面是一个磁盘控制器的寄存器：</p>
<p>5    5    9      8     1    1     1     1      1</p>
<p>上面的位段从左到右依次代表：5位的命令，5位的扇区，9位的磁道，8位的错误代码，1位的HEAD LOADED，1位的写保护，1位的DISK SPINNING, 1位的错误判断符，还有1位的READY位。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DISK_FORMAT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> command : <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> sector  :    <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> track : <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> err_code : <span class="number">8</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> ishead_loaded : <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> iswrit_proted : <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> isdisk_spinning : <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> iserr_ocur : <span class="number">1</span>;</span><br><span class="line">	undigned isready : <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>代码中除了第一行使用了unsigned int 来声明位段后就省去了int,这是可行的，ANCI C标准 </p>
</blockquote>
<hr>
<h2 id="函数的调用过程"><a href="#函数的调用过程" class="headerlink" title="函数的调用过程"></a><strong>函数的调用过程</strong></h2><p>在c语言中，遇到某函数时，会跳转执行这个函数，执行完毕再执行下一条指令，这些操作会通过形成一个栈帧完成。栈帧是编译器用来实现函数调用过程的一种数据结构。每个栈帧对应着一个未运行完的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> z=<span class="number">0</span>;</span><br><span class="line">	z=a+b;</span><br><span class="line">	<span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a=<span class="number">120</span>;</span><br><span class="line">	<span class="keyword">int</span> b=<span class="number">20</span>;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">    ret=Add(a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ret);</span><br><span class="line">    sys</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用main函数之前在调试-窗口-调用堆栈，中可以看到main函数是在mainCRTStartup被调用，这个过程要为函数开辟栈空间，这块栈空间我们称为函数栈帧。栈帧需要ebp和esp两个寄存器，在函数调用的过程中这两个寄存器存放了维护这个栈的栈底和栈顶指针。在汇编窗口可以看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">push   ebp</span><br><span class="line">mov    ebp,esp</span><br><span class="line">sub    esp, 0E4h</span><br><span class="line">push   ebx</span><br><span class="line">push   esi</span><br><span class="line">push   edi</span><br><span class="line">lea    edi, [ebp - 0E4h]</span><br><span class="line">mov    ecx, 39h</span><br><span class="line">mov    eax, 0CCCCCCh</span><br><span class="line">rep    stos    dword ptr es:[edi]</span><br></pre></td></tr></table></figure>



<p>1.压栈，把ebp放入栈顶，而esp始终指向栈顶</p>
<p>2.将esp值传给ebp，也就是让esp,ebo移到一起</p>
<p>3.sub为减的意思，即将esp-0E4h赋给esp,且函数调用分配由高地址向低地址增长，因此esp向上移动，即开辟了新空间，也就是为main函数开辟空间。</p>
<p>4.三个push压栈分别将ebx，esi,edi按顺序压入栈顶，而esp也会指向栈顶</p>
<p>5.lea指令，加载有效地址；将ebp-0E4h的地址放入edi中，也就是edi指向ebp-0E4h，把39h放到ecx中，把0ccccccch放在eax中；</p>
<p>从edi所指向的地址开始向高地址进行拷贝，拷贝的次数为ecx内容，拷贝的内容为eax内…</p>
<h2 id="栈帧的总结"><a href="#栈帧的总结" class="headerlink" title="栈帧的总结"></a><strong>栈帧的总结</strong></h2><p>1.堆栈是C语言程序运行时必须的一个记录调用路径和参数的空间：</p>
<p>函数调用框架；</p>
<p>传递参数；</p>
<p>保存返回地址；</p>
<p>提供局部变量空间；</p>
<p>2.堆栈寄存器和堆栈操作</p>
<p>堆栈相关的寄存器</p>
<p>esp,堆栈指针（stack pointer）</p>
<p>ebp,基址指针（base pointer）</p>
<p>堆栈操作</p>
<p>push 栈顶地址减少4个字节（32位）</p>
<p>pop 栈顶地址增加4个字节</p>
<p>ebp在C语言中用作记录当前函数调用基址</p>
<hr>
<p>表面上：</p>
<p>调用函数大连路边上浅层解释的步骤是：</p>
<p>1.通过函数名找到函数入口地址</p>
<p>2.给形参分配空间</p>
<p>3.传值：把实参变量对应内存空间的值传递给形参变量对应的空间</p>
<p>4.执行函数体语句</p>
<p>5.函数返回值并释放函数空间</p>
<p>在函数参数传递的过程中如何确定传值和传地址：</p>
<p>当只读（只使用不修改）实参变量的值时，传实参变量名；</p>
<p>当写（既使用也修改）实参变量对应内存空间的值，传实参变量对应内存空间的地址。</p>
<hr>
<p>另一种解释：</p>
<p>当一个程序开始运行时，他的代码被装入到内存，保存在代码区，包括主函数和其他函数的代码。另外，还有三块内存区域用来存放数据。第一块是全局变量区域，存放了程序当中的所有全局变量。由于全局变量的个数和大小是已知的，所以这一块区域所占用的内存大小在开始即可确定下来，它们被称为是静态分配。位于此区域内的变量，它们在程序的整个运行过程中，都一直存在，只有当整个程序运行结束了，这一块内存区域才会释放。第二块区域是栈区域，包含了所有的栈帧，所谓的栈帧就是在调用一个函数时，系统会自动分配一块内存区域给这个函数，用来保存它的运行上下文、形参和局部变量等信息，这样的一块内存区域，就叫做栈帧。栈帧是在函数调用时分配的，当函数调用结束后，相应的栈帧就会被释放。所以，对于一个函数的局部变量来说，只有当函数调用发生时，系统才会给这个函数的形参和局部变量分配存储空间；当函数调用结束后，这些局部变量就被释放了。另外，由于栈区域是由系统自动来分配的，用户并不需要去关心，所以也称为是自动分配。第三块区域是堆区域，他主要是用作动态分配的内存。</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">SIDPUAPI <span class="keyword">void</span> <span class="title">SVPHB</span><span class="params">(SVPHBAlg* pAlg)</span></span></span><br></pre></td></tr></table></figure>

<p>extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言（而不是C++）的方式编译。</p>
<h3 id="可重入函数和不可重入函数"><a href="#可重入函数和不可重入函数" class="headerlink" title="可重入函数和不可重入函数"></a><strong>可重入函数和不可重入函数</strong></h3><p>在函数中如果我们使用静态变量了，导致产生中断调用别的函数的过程可能还会调用这个函数，于是原来的静态变量被这里改变了，然后返回主体函数</p>
<h2 id="Kconfig-Makefile和-config"><a href="#Kconfig-Makefile和-config" class="headerlink" title="Kconfig,Makefile和.config"></a><strong>Kconfig,Makefile和.config</strong></h2><p>Makefile : 一个文本形式的文件，其中包含一些规则告诉make编译哪些文件以及怎样编译这些文件，</p>
<p>Kconfig：一个文本形式的文件，其中主要作用是在内核配置时候，作为配置选项。</p>
<p>.config:文件是在进行内核配置的时候，经过配置后生成的内核编译参考文件。</p>
<h2 id="Kconfig"><a href="#Kconfig" class="headerlink" title="Kconfig"></a>Kconfig</h2><p>一个典型的内核配置菜单如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu <span class="string">"Network device support"</span></span><br><span class="line"><span class="built_in">config</span> NETDEVICES</span><br><span class="line">	<span class="keyword">bool</span> <span class="string">"Enable Net Devices"</span></span><br><span class="line">    depends on NET</span><br><span class="line">    defailt y</span><br><span class="line">    help</span><br><span class="line">    	This is help desciption.</span><br><span class="line">...</span><br><span class="line"><span class="built_in">end</span> menu</span><br></pre></td></tr></table></figure>

<p>包含在menu/endmenu中的内容会成为Network device support的子菜单。每个子菜单项都是由config来定义的。config下方的那些bool, depends on,help等为config的属性，用于定义该菜单的类型、依赖项、默认值、帮助信息等。</p>
<p>2、补充说明一下类型定义部分</p>
<p>每个config菜单项都要有类型定义：bool布尔类型，tristate三态（内建，模块，移除）、string字符串、hex十六进制、integer整型。</p>
<p>例如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">config</span> HELLO_MODULE</span><br><span class="line"><span class="keyword">bool</span> <span class="string">"hello test module"</span></span><br></pre></td></tr></table></figure>

<p>bool类型的只能选中或不选中，显示为[]；tristate类型的菜单项多了编译成内核模块的选项，显示为&lt;&gt;，假如选中内建，就是直接编译成内核影响，就会在.config中生成一个CONFIG_HELLO_MODULE=m的配置，假如选择内建，就是直接编译成内核影响，就会在.config中生成一个CONFIG_HELLO_MODULE=y的配置，hex十六进制类型显示为（）。</p>
<p>3、目录层次迭代</p>
<p>在Kconfig中有类似语句：source “divers/usb/Kconfig”</p>
<p>用来包含（或嵌套）新的Kconfig文件，这样便可以使各个目录管理各自的配置内容，使不必把那些配置都写在同一文件里，方便修改和管理。</p>
<hr>
<h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a><strong>Makefile</strong></h3><p>2.6内核的Makefile分为5个组成部分：</p>
<p>1.最顶层的Makefile</p>
<p>2.内核的.config配置文件</p>
<p>3.在arch/$(ARCH)目录下的体系结构相关的Makefile</p>
<p>4.在s目录下的Makefile.*文件，是一些Makenfile的通用规则</p>
<p>5.各级目录下的大概约500个kbuild Makefile文件</p>
<p>顶层的Makefile文件读取.config文件的内容，并总体上负责build内核和模块。Arch Make则提供补充体系结构相关的信息。s目录下的Makefile文件包含了所有用来根据kbuild Makefile构建内核所需的定义和规则。</p>
<p>Kuild Makefile核心内容是：</p>
<p>1.目标定义</p>
<p>目标定义是用来定义哪些内容要做为模块编译，哪些要编译连接进内核。</p>
<p>obj-y += foo.o</p>
<p>表示要由foo.c或者foo.s文件编译到得到foo.o并连接进内核，而obj-m则表示该文件要作为模块编译。除了y,m以外的obj-x形式的目标都不会被编译。而更常见的做法是根据.config文件的CONFIG_变量来决定文件的编译方式。如：</p>
<p>obj-$(CONFIG_EXT2) += ext2.o</p>
<p>除了Obj-形式的目标以外，还有lib-y library 库，hostprogs-y主机程序等目标，但是基本都应用在特定的目录和场合下。</p>
<hr>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200721131854374.png" alt="image-20200721131854374"></p>
<p>上面是有问题的程序</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  
  
  

</article>
    
    <article id="post-深度学习" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/07/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"
    >深度学习</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/07/07/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2020-07-07T02:52:22.000Z" itemprop="datePublished">2020-07-07</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h2 id="深度学习专业术语"><a href="#深度学习专业术语" class="headerlink" title="深度学习专业术语"></a><strong>深度学习专业术语</strong></h2><p>conv 3-64       (三个通道图片，64个卷积核)</p>
<p>卷积核：就是处理图像时，给定输入图像，输入图像中一个小区域中像素加权平均后成为输出图像中的每个对应像素，其中权值由一个函数定义，这个函数成为卷积核。</p>
<p>卷积核具有一个属性就是局部性，只关注局部特征，局部的程度取决于卷积核的大小。也可以另外一个角度理解卷积的意义，学过信号处理的，时域卷积对应频域相乘，所以原图像与卷积核的卷积其实是对频域信息进行选择。</p>
<h3 id="VGG16网络结构"><a href="#VGG16网络结构" class="headerlink" title="VGG16网络结构"></a><strong>VGG16网络结构</strong></h3><p>用池化层作为分界，VGG16共有6个块结构，每个块结构中的通道数相同。因为卷积层和全连接层都有权重系数，也被称为权重层，其中卷积层13，全连接层3层，池化层不涉及权重。总共13+3=16层。</p>
<p>对于VGG16卷积神经网络而言，其13层卷积层和5层池化层负责进行特征的提取，最后的的3层全连接层负责完成分类。</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200707135033922.png" alt="image-20200707135033922"></p>
<p><strong>VGG16的卷积核</strong></p>
<p>卷积层都是3*3的卷积核，conv3-xxx表示，xxx表示通道数。其步长为1，用padding=same填充。</p>
<p>池化层的池化核为2*2.</p>
<p>MaxPooling的作用</p>
<p>1.不变性，包括平移，旋转，尺度</p>
<p>2.保留主要的特征同时减少参数（降维，效果类似PCA）和计算量，防止过拟合，提高模型泛化能力。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  
  
  

</article>
    
    <article id="post-C-常用的东西" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/06/C-%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%9C%E8%A5%BF/"
    >C++常用的东西</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/07/06/C-%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%9C%E8%A5%BF/" class="article-date">
  <time datetime="2020-07-06T08:31:07.000Z" itemprop="datePublished">2020-07-06</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h3 id="inline"><a href="#inline" class="headerlink" title="inline"></a><strong>inline</strong></h3><p>C++关键字，函数返回类型前加inline,即可以把函数指定为内联函数。这样可以解决一些频繁调用的函数大量消耗栈空间（栈内存）的问题。关键字inline必须与函数定义放在一起才能使函数成为内联函数。是一种“用于实现”的关键字。</p>
<p>：：</p>
<p>表示作用域，和所属关系。比如一个A类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	pulic:</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在一个函数test属于A</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">A::test</span><span class="params">()</span>    <span class="comment">//表示test是属于A的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>::是运算符中等级最高的，它分为三种：</p>
<ul>
<li><p>全局作用符，（：：name）</p>
</li>
<li><p>类作用域符，（class :: name）</p>
</li>
<li><p>命名空间作用域符 ， 用法（namespace :: name）</p>
</li>
</ul>
<p>：</p>
<ul>
<li><p>类名后加冒号用来定义类的继承</p>
</li>
<li><p>构造函数后加冒号是初始化表达式：比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iStack(<span class="keyword">int</span> capacity) : _stack(capacity), _top(<span class="number">0</span>)&#123;&#125;</span><br><span class="line"><span class="comment">//冒号后面的内容是初始化类的数据成员_top;_stak;</span></span><br><span class="line"><span class="comment">//也这样写;</span></span><br><span class="line">iStack(<span class="keyword">int</span> capacity)</span><br><span class="line">&#123;</span><br><span class="line">	_stack(capacity);</span><br><span class="line">	_top(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>表示机构内位域的定义（即该变量占几个bit空间）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> struct_XXX&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> a:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> c;</span><br><span class="line">&#125;; XXX</span><br></pre></td></tr></table></figure>
</li>
<li><p>用于public和privare后，表示后面的所有成员是公有或者私有；</p>
</li>
</ul>
<h3 id="pragma-pack"><a href="#pragma-pack" class="headerlink" title="#pragma pack"></a><strong>#pragma pack</strong></h3><p>语法： #pragma pack([sow] | [push | pop] [,identifier], n)</p>
<p>pack为struct,union和class等的成员对齐指定字节边界。</p>
<ul>
<li><p>#pragma pack(n)       将当前字节对齐值设为n</p>
</li>
<li><p>#pragma pack()    将当前字节对齐值设备默认值（通常是8） </p>
<p>…</p>
</li>
</ul>
<h3 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a><strong>对齐</strong></h3><p>各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对齐数据存放进行对齐，会在存取效率上带来损失。</p>
<p><strong>结构体对齐规则</strong></p>
<p>结构体中各个成员按照它们被声明的顺序在内存中顺序存储；</p>
<p>1）将结构体内所有数据成员的长度值相加，记为sum_a;</p>
<p>2）将各数据成员内存对齐，按各自对齐模数而填充的字节数累加到和sum_a上，记为sum_b。对齐模数是【该数据成员所占内存】与【#pragma pack指定的数值】中的较小者。</p>
<p>3）将和sum_b向结构体模数对齐，该模数是【#pragma pack指定的数值】、【未指定#pragma pack时，系统默认的对齐模数8字节】和【结构体内部最大的基本数据类型成员】长度中数值较小者。结构体的长度应该是该模数的整数倍。</p>
<h3 id="基本数据类型所占内存大小"><a href="#基本数据类型所占内存大小" class="headerlink" title="基本数据类型所占内存大小"></a><strong>基本数据类型所占内存大小</strong></h3><table>
<thead>
<tr>
<th></th>
<th>char</th>
<th>bool</th>
<th>short</th>
<th>int</th>
<th>unsigned int</th>
<th>float</th>
<th>long</th>
<th align="center">double</th>
<th>long long</th>
<th>long double</th>
<th>指针</th>
</tr>
</thead>
<tbody><tr>
<td>32bit编译器</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td align="center">8</td>
<td>8</td>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td>64bit编译器</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>8</td>
<td align="center">8</td>
<td>8</td>
<td>8</td>
<td>8</td>
</tr>
</tbody></table>
<p>按32bit编译器处理为例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> c;        <span class="comment">//1  </span></span><br><span class="line">	short sh;      <span class="comment">//2 </span></span><br><span class="line">	<span class="keyword">int</span> a;         <span class="comment">//4</span></span><br><span class="line">	<span class="keyword">float</span> f;       <span class="comment">//4</span></span><br><span class="line">	<span class="keyword">int</span> *p;        <span class="comment">//</span></span><br><span class="line">	<span class="keyword">char</span> *s;</span><br><span class="line">	<span class="keyword">double</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总共占28Bytes，c的偏移量为0，占1Byte, sh占2Byte, 它的对齐模数是2（2&lt;4,取小者），存放起始地址应该是2的整数倍，因此c后填充1个空字符，sh的起始地址是2。a占4Byte,对齐模式是4，因此在sh后存放即可，偏移量为4。f占4个字节，对齐模式是4，存放地址是4的整数倍，起始地址是8。p,s的起始地址分别是12,16.d占8个字节，对齐模式是4（4&lt;8）,d从偏移地址为20处存放。存放后结构体占28个字节，是4的整数倍不用补空字符。</p>
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>C</td>
<td>null</td>
<td>sh</td>
<td>sh</td>
</tr>
<tr>
<td>2</td>
<td>a</td>
<td>a</td>
<td>a</td>
<td>a</td>
</tr>
<tr>
<td>3</td>
<td>f</td>
<td>f</td>
<td>f</td>
<td>f</td>
</tr>
<tr>
<td>4</td>
<td>p</td>
<td>p</td>
<td>p</td>
<td>p</td>
</tr>
<tr>
<td>5</td>
<td>s</td>
<td>s</td>
<td>s</td>
<td>s</td>
</tr>
<tr>
<td>6</td>
<td>d</td>
<td>d</td>
<td>d</td>
<td>d</td>
</tr>
<tr>
<td>7</td>
<td>d</td>
<td>d</td>
<td>d</td>
<td>d</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">	<span class="keyword">double</span> d;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	short sh;</span><br><span class="line">	<span class="keyword">float</span> f;</span><br><span class="line">	<span class="keyword">int</span> *p;</span><br><span class="line">	<span class="keyword">char</span> *s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>c</td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>2</td>
<td>d</td>
<td>d</td>
<td>d</td>
<td>d</td>
</tr>
<tr>
<td>3</td>
<td>d</td>
<td>d</td>
<td>d</td>
<td>d</td>
</tr>
<tr>
<td>4</td>
<td>a</td>
<td>a</td>
<td>a</td>
<td>a</td>
</tr>
<tr>
<td>5</td>
<td>sh</td>
<td>sh</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>6</td>
<td>f</td>
<td>f</td>
<td>f</td>
<td>f</td>
</tr>
<tr>
<td>7</td>
<td>p</td>
<td>p</td>
<td>p</td>
<td>p</td>
</tr>
<tr>
<td>8</td>
<td>s</td>
<td>s</td>
<td>s</td>
<td>s</td>
</tr>
</tbody></table>
<p><strong>函数是什么</strong></p>
<p><strong>函数的调用过程</strong></p>
<p>在c语言中到某一个函数时，它就会跳转过去执行这个函数，执行完毕后接着再去执行下一条指令。在执行调用函数的过程中，计算机通常还要根据函数完成一些工作，这些操作通过形成一个栈帧来完成。栈帧是编译器用来实现函数调用过程的一种数据结构。C语言中，每个栈帧对应着一个未运行完的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在数据结构中, 栈是限定仅在表尾进行插入或删除操作的线性表。栈是一种数据结构，它按照后进先出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据。</span><br></pre></td></tr></table></figure>
















      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  
  
  

</article>
    
    <article id="post-Linux命令" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/06/Linux%E5%91%BD%E4%BB%A4/"
    >Linux命令</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/07/06/Linux%E5%91%BD%E4%BB%A4/" class="article-date">
  <time datetime="2020-07-06T06:21:48.000Z" itemprop="datePublished">2020-07-06</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a><strong>pwd</strong></h3><p>显示当前的工作目录，执行pwd指令可立刻知道目前所在的工作目录的绝对路径名称；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure>

<h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a><strong>rm</strong></h3><p>用来删除某个目录及其下的所有文件及其子目录。对于链接文件，只是断了链接，原文件保持不变。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm [选项] 文件或目录</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>选项</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td>-r</td>
<td align="left">将选型中列出的全部目录以及子目录还有文件均递归地删除，如果在选项中不指定“-r”选项，“rm”命令将不能删除目录</td>
</tr>
<tr>
<td>-f</td>
<td align="left">忽略不存在的问题，也不给提示</td>
</tr>
<tr>
<td>-i</td>
<td align="left">交互式删除，即在删除前进行确认</td>
</tr>
</tbody></table>
<blockquote>
<p>使用“rm-rf”组合要谨慎，因为文件一旦被删除，就不能恢复。rm的“-i”选项需要输入y，文件才被删除，输入其他信息不被删除。</p>
</blockquote>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  
  
  

</article>
    
    <article id="post-破解AD14软件的步骤" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/06/%E7%A0%B4%E8%A7%A3AD14%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%AD%A5%E9%AA%A4/"
    >破解AD14软件的步骤</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/07/06/%E7%A0%B4%E8%A7%A3AD14%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%AD%A5%E9%AA%A4/" class="article-date">
  <time datetime="2020-07-06T01:36:06.000Z" itemprop="datePublished">2020-07-06</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>找到解压文件的Mechine，将DXP文件复制替换到软件安装的文件夹中，双击DXP文件，然后</p>
<p>在Add standalone license file位置点击</p>
<p> <img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200706094202521.png" alt="image-20200706094202521"></p>
<p>在License 文件中选任意一个破解文件即可。</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200706094301758.png" alt="image-20200706094301758"></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  
  
  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2020
        <i class="ri-heart-fill heart_icon"></i> Chen Bin
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="梦想岛"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">算法与程序设计</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E4%BB%A3%E7%A0%81%E8%AF%B4/">代码说</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="http://chenbin-vip.lofter.com" target="_blank" rel="noopener">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E5%A4%96%E8%AF%AD%E5%AD%A6%E4%B9%A0/">外语学习</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84/">法律法规</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/about/">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://i.loli.net/2020/04/24/VjamHOiTgk26EpK.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://i.loli.net/2020/04/24/FMJN75HGXRpDdP4.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Subtitle -->

<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
      startDelay: 0,
      typeSpeed: 180,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
    console.log(err)
  }
</script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>

<!-- Katex -->


    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css">
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"></script>
        
    


<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->


<script src="/js/clickLove.js"></script>


<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>



    
  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

</html>