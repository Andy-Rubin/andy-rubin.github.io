<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="学习，生活，思考，代码，博客" />
   
  <meta name="description" content="梦想的萌生岛" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     梦想岛
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

<link rel="alternate" href="/atom.xml" title="梦想岛" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Andy-Rubin/andy-rubin.github.io"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover6.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">梦想岛</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-ANDROID-0" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/24/ANDROID-0/"
    >ANDROID</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/07/24/ANDROID-0/" class="article-date">
  <time datetime="2020-07-24T12:18:10.000Z" itemprop="datePublished">2020-07-24</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h2 id="Android说"><a href="#Android说" class="headerlink" title="Android说"></a><strong>Android说</strong></h2><p><strong>res目录</strong></p>
<p>存放Android项目的各种资源，比如layout,存放界面布局文件；values目录下则存放各种XML格式的资源文件，例如字符串资源文件：string.xml；颜色资源文件：colors.xml;尺寸资源文件：dimens.xml，drawable-ldpi,drawable-mdpi,drawable-hdpi,drawable-xhdpi这个4个子目录则分别用于存放分辨率、中分辨率、高分辨路、超高分辨率的4中图片文件。</p>
<hr>
<p>res目录是一个特殊的项目，里面存放了Android应用所用的全部资源，包括图片资源、字符串资源、颜色资源、尺寸资源等。</p>
<p>按照约定，将不同的资源放在不同的文件夹内，这样可以方便地让aapt工具来扫描这些资源，并未它们生成对应的资源清单类：R.java</p>
<p>例子： res/value/string.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">"app_name"</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面资源文件中定义了一个字符串常量，常量的值为HelloWorld,一旦定义了这份字符串常量，Android项目就允许分别在java代码、XML文件中使用这份资源文件中的字符串资源。</p>
<p><strong>1.在Java代码中使用资源</strong></p>
<p>为了在Java代码中使用资源，AAPT会为Android项目自动生成一份R.java文件，R类里为每份资源分别定义了一个内部类，其中每个资源项对应于内部类里一个Int类型的Field。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> app_name=<span class="number">0x7f040000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>借助于AAPT自动生成R类的帮助，在JAVA代码中通过R.string.app_name引用到“Hello World”字符串常量。</p>
<p><strong>2.在xml文件中使用资源</strong></p>
<p>在XML文件中使用资源更加简单，只要按照如下格式来访问即可</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="tag">&lt;<span class="name">资源对应的内部类的类名</span>&gt;</span>/<span class="tag">&lt;<span class="name">资源项的名称</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>比如我们要访问上面的字符串资源中定义的“HelloWorld”字符串常量，则使用如下形式引用：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@string/app_name</span><br></pre></td></tr></table></figure>

<p>还有一种情况：为该组件分配标识符</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@+id/<span class="tag">&lt;<span class="name">标识符代号</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:id="@+id/ok"</span><br></pre></td></tr></table></figure>

<p>接下来就可以在程序中引用该组件。</p>
<p>如果在Java中获取该组件，通过调用Activity的findViewById()方法即可实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@id&#x2F;&lt;标识符代号&gt;</span><br></pre></td></tr></table></figure>

<p><strong>src目录</strong></p>
<p>只是一个普通的、保存Java源文件的目录。</p>
<p><strong>AndroidManifest.xml</strong></p>
<p>文件时Android项目的系统清单文件，它用于控制Android应用的名称、图标、访问权限等整体属性。除此之外，Android应用的Activity、Service、ContentProvider、BroadcastReceiver这4大组件都需要在该文件中配置。</p>
<p><strong>gen目录</strong></p>
<p>用于保存自动生成的、位于Android项目包下的R.java文件。R.java可以理解成Android应用的资源字典。</p>
<p>AAPT:</p>
<p>aapt即Android Asset Packaging Tool，在SDK的build-tools目录下。该工具可以查看，创建， 更新ZIP格式的文档附件(zip, jar, apk)。也可将资源文件编译成<a href="https://baike.so.com/doc/6848461-7065887.html" target="_blank" rel="noopener">二进制文件</a>，尽管你可能没有直接使用过aapt工具，但是build scripts和IDE<a href="https://baike.so.com/doc/1483288-1568456.html" target="_blank" rel="noopener">插件</a>会使用这个工具打包apk文件构成一个Android 应用程序。在使用aapt之前需要在环境变量里面配置SDK-tools路径，或者是路径+aapt的方式进入aapt。</p>
<p>AAPT生成R.java文件的规则主要是如下两条：</p>
<ul>
<li>每类资源都对应于R类的一个内部类。比如所有界面布局资源对应于layout内部类；所有字符串资源对应于string内部类；所有标识符资源对应于id内部类；</li>
<li>每个具体的资源项都对应于内部类的一个public staitc final int类型的Field。</li>
</ul>
<p><strong>bin目录</strong></p>
<p>该目录用于存放生成的目标文件，如Java的二进制文件、资源打包文件（.ap_后缀），Dalvik虚拟机的可执行性文件（.dex后缀）等</p>
<hr>
<p><strong>AnndroidManifest.xml ： Android应用清单文件</strong></p>
<p>是整个Android应用的全局描述文件，说明了该应用的名称，所使用的图标以及包含的组件等。</p>
<p>包含信息如下：</p>
<ul>
<li>应用程序的包名，该包名将会作为该应用的唯一标识</li>
<li>应用程序所包含的组件，如Activity,Service,BroadcastReceiver和ContentProvider等</li>
<li>应用程序兼容的最低版本</li>
<li>应用程序使用系统所需的权限声明</li>
<li>其他程序访问该程序所需的权限声明</li>
</ul>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200725210654538.png" alt="image-20200725210654538"></p>
<p>Android应用基本组件</p>
<h2 id="1-Activity"><a href="#1-Activity" class="headerlink" title="1.Activity"></a><strong>1.Activity</strong></h2><p>Activity是Android应用中负责与用户交互的组件——大致上可以想象成Swing编程中的JFrame组件。区别就是：JFrame本身可以设置布局管理器，不断地向JFrame中添加组件，但Activity只能通过setContentView(view)来显示指定的组件。</p>
<p>View组件是所有UI控件、容器控件的基类，View组件就是Android应用中用户实实在在看到部分。但View组件需要放到容器组件中，或者使用Activity将它显示出来。如果需要通过某个Activity把指定View显示出来，调用Activity的setContentView()方法即可。</p>
<p>setContentView()方法可接收一个View对象作为参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个线性布局管理器</span></span><br><span class="line">LinearLayout layout = <span class="keyword">new</span> LinearLayout(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//设置该Activity显示layout</span></span><br><span class="line">setContentView(layout);</span><br></pre></td></tr></table></figure>

<p>setContentView()方法也接受一个布局管理资源的ID作为参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置该Activity显示main.xml文件定义的View</span></span><br><span class="line">setContentView(R.layout.main);</span><br></pre></td></tr></table></figure>

<h2 id="2-Service"><a href="#2-Service" class="headerlink" title="2.Service"></a><strong>2.Service</strong></h2><p>​       Service与Activity的地位是并列的，他也代表一个单独的Android组件。Service与Activity区别在于它一直在后台运行，一般不需要与用户交互，因此Service组件没有图像用户界面。</p>
<p>​       和Activity组件需要继承Activity基类相似，Service组件需要继承Service基类。一个Service组件被运行起来之后，他将拥有自己独立的生命周期，Service组件通常用于为其他组件提供后台服务或者监控其它组件的运行状态。</p>
<h2 id="3-BroadcastReceiver"><a href="#3-BroadcastReceiver" class="headerlink" title="3.BroadcastReceiver"></a><strong>3.BroadcastReceiver</strong></h2><p>是Android应用中另一个重要的组件，BroadcastReceiver代表广播消息接收器。从代码实现角度看，BroacastReceiver非常类似于事件编程中的监听器。与普通事件监听器不同的是，普通事件监听器监听的事件源是程序中的对象；而BroadcastReceiver监听的事件源是Android应用中的其他组件。</p>
<p>使用BroadcastReceiver组件接收广播消息比较简单，开发者只要实现自己的BroadcastReceiver子类，并重写onReceive(Context context, Intent intent)方法即可。当其他组件通过sendBroadcast()、sendStickyBroadcast()或sendOrderedBroad()方法发送广播消息时，如果该BroadcastReceiver也对该消息“感兴趣”（通过IntentFilter配置），BroadcastReceiver的onReceive（Context context, Intent intent）方法将会被触发。</p>
<p>开发者实现了自己的BroadcastReceiver之后，通常有两种方法来注册这个系统级的“事件监听器”</p>
<ul>
<li>在Java代码中通过Context.registReceiver()方法注册BroadcastReceiver</li>
<li>在AndroidManifest.xml文件中使用&lt;reciever…/&gt;元素完成注册。</li>
</ul>
<h2 id="4-ContentProvider"><a href="#4-ContentProvider" class="headerlink" title="4.ContentProvider"></a><strong>4.ContentProvider</strong></h2><p>Android会有各个应用程序之间交换数据的时候，Android系统为这种跨应用的数据交换提供了一个标准：ContentProvider。当用户实现自己ContentProvider时，需要实现如下抽象方法：</p>
<ul>
<li>insert(Uri, ContentValues):向ContentProvider插入数据。</li>
<li>delete(Uri,ContentValues)：删除ContentProvider中指定数据</li>
<li>updata(Uri,ContentValues,String, String[]) ：更新ContentProvider中指定数据</li>
<li>query(Uri,String[], String,String[],String):从ContentProvider查询数据。</li>
</ul>
<p>通常与ContentProvider结合使用的是ContentResolver,一个应用程序使用ContentProvider暴露自己的数据，而另一个应用程序则通过ContentResolver来访问数据。</p>
<h3 id="使用Android-Studio-对-Android应用签名"><a href="#使用Android-Studio-对-Android应用签名" class="headerlink" title="使用Android Studio 对 Android应用签名"></a><strong>使用Android Studio 对 Android应用签名</strong></h3><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200729153412733.png" alt="image-20200729153412733"></p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200729153504203.png" alt="image-20200729153504203"></p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200729153541663.png" alt="image-20200729153541663"></p>
<p>如果有私密玥要文件就用有的再输入密码就可以。没有就接着看：</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200729154113853.png" alt="image-20200729154113853"></p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200729154128210.png" alt="image-20200729154128210"></p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200729154335791.png" alt="image-20200729154335791"></p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200729154440350.png" alt="image-20200729154440350"></p>
<p>有时候新建Android工程会缺少R.java文件，就需要在</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200729165710922.png" alt="image-20200729165710922"></p>
<p>这里勾上Build Auto….</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  
  
  

</article>
    
    <article id="post-C-的头文件" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/20/C-%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6/"
    >C++的头文件</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/07/20/C-%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6/" class="article-date">
  <time datetime="2020-07-20T02:04:01.000Z" itemprop="datePublished">2020-07-20</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h2 id="C-的头文件细说"><a href="#C-的头文件细说" class="headerlink" title="C++的头文件细说"></a><strong>C++的头文件细说</strong></h2><h3 id="unistd-h"><a href="#unistd-h" class="headerlink" title="unistd.h"></a><strong>unistd.h</strong></h3><p>提供对POSIX操作系统API的访问功能，其中调用的接口大量都是对系统调用的封装。</p>
<blockquote>
<p>引申：    POSIX（Portable Operating System Interface of UNIX, POSIX）表示可移植操作系统接口，POSIX标准定义了操作系统应该为应用程序提供的接口标准，是IEEE为要在各种UNIX操作系统上运行的软件定义的一系列API标准的总称。</p>
<p>主流操作系统有两种，一种是Window系统，另一种是LINUX系统，由于系统不同，API又分为WINDOWS API和Linux API。两者在各自平台上开发出来的软件就无法在对方上运行，导致软件移植困难，POSIX（可移植操作系统规范）应运而生。</p>
<p>linux和Windows都要实现基本的posix标准，linux把fork函数封装成posix_fork（随便说的），windows把creatprocess也封装成posix_fork，都声明在unistd.h里。这样，程序员在编写普通应用的时候，只用包含unistd.h，调用posix_fork函数，程序就在源代码级别可移植了。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fork()  <span class="comment">//复制进程</span></span><br><span class="line">pipe()  <span class="comment">//管道，即把两个进程之间的标准输入和标准输出连接起来的机制，从而提供一种让多个进程间通信的方法</span></span><br></pre></td></tr></table></figure>

<h3 id="arpa-inet-h"><a href="#arpa-inet-h" class="headerlink" title="arpa/inet.h"></a><strong>arpa/inet.h</strong></h3><p>定义了更多的网络类型和函数（包含netline/in.h）,如inet_addr,inet_aton等</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  
  
  

</article>
    
    <article id="post-TCP-IP网络编程" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/20/TCP-IP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"
    >TCP/IP网络编程</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/07/20/TCP-IP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="article-date">
  <time datetime="2020-07-20T01:25:50.000Z" itemprop="datePublished">2020-07-20</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h2 id="TCP-IP网络编程"><a href="#TCP-IP网络编程" class="headerlink" title="TCP/IP网络编程"></a><strong>TCP/IP网络编程</strong></h2><p><strong>构建电话套接字</strong></p>
<p>套接字一般分两种，TCP套接字可以比喻成电话机，电话机可以同时拨打或接听，但对套接字而言拨打和接听是有区别的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>

<p>上面函数就是相当于电话机的套接字。</p>
<p>准备好电话机（预定义了套接字，以后可以直接用）就需要考虑分配电话号码的问题，这样别人才能联系到自己。</p>
<p><strong>调用bind函数（分配电话号码）时进行的对话</strong></p>
<p>利用下面的函数给创建好的套接字分配地址信息（IP地址和端口号）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *myaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>; </span><br><span class="line"><span class="comment">//成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure>

<p>调用bind函数给套接字分配地址后，就基本完成了接电话的所有准备工作。接下来需要连接电话线并等待来电。（相当于知道了电话号码了）</p>
<p><strong>调用listen函数（连接电话线）时进行的对话</strong></p>
<p>​       一连接电话线，电话机就转为可接听状态，这时其他人可以拨打电话请求连接到该机。同样，需要把套接字转化成可接收连接的状态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>

<p>连接好电话线，如果有人拨打，需要拿起话筒才能接听电话。</p>
<p><strong>调用accept函数（拿起话筒）时进行的对话</strong></p>
<p>拿起话筒意味着接收了对方的连接请求。套接字同样如此，如果有人为了完成数据传输而请求连接，就需要调用以下函数进行受理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="网络编程中接受连接请求的套接字创建过程可整理如下："><a href="#网络编程中接受连接请求的套接字创建过程可整理如下：" class="headerlink" title="网络编程中接受连接请求的套接字创建过程可整理如下："></a><strong>网络编程中接受连接请求的套接字创建过程可整理如下：</strong></h3><ul>
<li>第一步：调用socket函数<strong>创建套接字</strong></li>
<li>第二步：调用bind函数<strong>分配IP地址和端口号</strong></li>
<li>第三部：调用listen函数转为可接收请求状态</li>
<li>第四部：调用accept函数受理连接请求。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hello_server.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> serve_sock;</span><br><span class="line">    <span class="keyword">int</span> clnt_sock;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clnt_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clnt_addr_size;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> message[]=<span class="string">"Hello World!"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage : %s &lt;port&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    serv_sock=sock(PE_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(serv_sock == <span class="number">-1</span>)&#123;</span><br><span class="line">        error_handling(<span class="string">"socket() error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sinfamily = AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(bind(serv_sock, (struck sockaddr*) &amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr))==<span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"bind() error"</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">listen</span>(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"listen() error"</span>);</span><br><span class="line">    clnt_addr_size=<span class="keyword">sizeof</span>(clnt_addr);</span><br><span class="line">    clnt_sock = accept(serv_sock, (struct sockaddr*)&amp;clnt_addr, &amp;clnt_addr_size);</span><br><span class="line">    <span class="keyword">if</span>(clnt_sock == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"accept() error"</span>);</span><br><span class="line">    <span class="built_in">write</span>(clnt_sock, message, <span class="keyword">sizeof</span>(message));</span><br><span class="line">    <span class="built_in">close</span>(clnt_sock);</span><br><span class="line">    <span class="built_in">close</span>(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">'\n'</span>,<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构建打电话套接字"><a href="#构建打电话套接字" class="headerlink" title="构建打电话套接字"></a><strong>构建打电话套接字</strong></h3><p>服务器端创建的套接字又称为服务器套接字或监听（listening）套接字。接下来介绍的套接字是用于请求连接的客户端套接字。客户端套接字的创建过程比创建服务器端套接字简单。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *serv_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hello_client.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa.inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> message[<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">int</span> str_len;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Usage : %s &lt;IP&gt;&lt;port&gt; \n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sock = socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sock == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"socket() error"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family=AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_add = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_addr.sin_port=htons(atoi[<span class="number">2</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">connect</span>(sock, (struct sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr))==<span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">"connect()) error!"</span>);</span><br><span class="line">    str_len = <span class="built_in">read</span>(sock, message, <span class="keyword">sizeof</span>(message)<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(str_len==<span class="number">-1</span>)&#123;</span><br><span class="line">        error_handling(<span class="string">"read() error!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Message from server : %s \n"</span>, message);</span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handling</span><span class="params">(<span class="keyword">char</span> *message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(messagem <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">'\n'</span>,<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>












      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  
  
  

</article>
    
    <article id="post-工程说" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/10/%E5%B7%A5%E7%A8%8B%E8%AF%B4/"
    >工程说</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/07/10/%E5%B7%A5%E7%A8%8B%E8%AF%B4/" class="article-date">
  <time datetime="2020-07-10T02:19:01.000Z" itemprop="datePublished">2020-07-10</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(n)         <span class="comment">//作用：C编译器将按照n个字节对齐</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()          <span class="comment">//作用：取消自定义字节对齐方式</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push,1)    <span class="comment">//作用：是指把原来对齐方式设置压栈，并设新的对齐方式设置为一个字节对齐</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)       <span class="comment">//作用：恢复对齐状态</span></span></span><br><span class="line"></span><br><span class="line">加入push和pop可以使对齐恢复到原来状态，而不是编译器默认，可以说后者更优，但是很多时候两者差别不大</span><br><span class="line">    </span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push)      <span class="comment">//保存对齐状态</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)         <span class="comment">//设定为4字节对齐     相当于  #pragma pack(push,4)</span></span></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1)         <span class="comment">//作用：调整结构体的边界对齐，让其以一个字节对齐；</span></span></span><br><span class="line">&lt;结构体按<span class="number">1</span>字节方式对齐&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">    </span><br><span class="line">例如：    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br><span class="line">--------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<p>应用实例</p>
<p>在网络协议编程中，经常会处理不同协议的数据报文。一种方法是通过指针偏移的方法得到各种信息，但这样做不仅编程复杂，而且一旦协议变化，程序修改起来比较麻烦。在了解编译器对结构空间的分配原则后，我们完全可以利用这一特性定义自己的协议结构，通过访问结构的成员来获取各种信息。</p>
<p>下面以TCP协议首部为例，说明如何定义协议结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#pragma pack(1)     &#x2F;&#x2F;按照1字节进行对齐</span><br><span class="line"></span><br><span class="line">struck TCPHEADER&#123;</span><br><span class="line">	short SrcPort; &#x2F;&#x2F;16位源端口号</span><br><span class="line">	short DstPort; &#x2F;&#x2F;16位目的端口号</span><br><span class="line">	int SeriaNo;   &#x2F;&#x2F;32位序列号</span><br><span class="line">	int AckNO;     &#x2F;&#x2F;32位确认号</span><br><span class="line">	unsigned char  HaderLen : 4;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="用结构体实现位段"><a href="#用结构体实现位段" class="headerlink" title="用结构体实现位段"></a><strong>用结构体实现位段</strong></h2><p>位段作用:位段是在字段的声明后面加一个冒号以及一个表示字段位长的整数来实现。这种用法又被叫：深入逻辑元件的编程。</p>
<p>使用位段理由：1.他能把长度为奇数的数据包装在一起，从而节省存储的空间；2.他可以很方便地访问一个整型值得部分内容。</p>
<blockquote>
<p>注意：</p>
<ul>
<li>位段成员只有三种类型：int, unsigned int 和 signed int这三种；</li>
<li>成员名后面的一个冒号和一个整数，这个整数指定该位段的位长(bit);</li>
<li>许多编译器把位段成员的字长限制在一个int的长度范围之内；</li>
<li>位段成员在内存的实现是从左到右还是从右到左是由编译器来决定的，但二者皆对。</li>
</ul>
</blockquote>
<p>磁盘控制器用于和软驱通信，下面是一个磁盘控制器的寄存器：</p>
<p>5    5    9      8     1    1     1     1      1</p>
<p>上面的位段从左到右依次代表：5位的命令，5位的扇区，9位的磁道，8位的错误代码，1位的HEAD LOADED，1位的写保护，1位的DISK SPINNING, 1位的错误判断符，还有1位的READY位。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DISK_FORMAT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> command : <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> sector  :    <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> track : <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> err_code : <span class="number">8</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> ishead_loaded : <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> iswrit_proted : <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> isdisk_spinning : <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> iserr_ocur : <span class="number">1</span>;</span><br><span class="line">	undigned isready : <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>代码中除了第一行使用了unsigned int 来声明位段后就省去了int,这是可行的，ANCI C标准 </p>
</blockquote>
<hr>
<h2 id="函数的调用过程"><a href="#函数的调用过程" class="headerlink" title="函数的调用过程"></a><strong>函数的调用过程</strong></h2><p>在c语言中，遇到某函数时，会跳转执行这个函数，执行完毕再执行下一条指令，这些操作会通过形成一个栈帧完成。栈帧是编译器用来实现函数调用过程的一种数据结构。每个栈帧对应着一个未运行完的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> z=<span class="number">0</span>;</span><br><span class="line">	z=a+b;</span><br><span class="line">	<span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a=<span class="number">120</span>;</span><br><span class="line">	<span class="keyword">int</span> b=<span class="number">20</span>;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">    ret=Add(a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ret);</span><br><span class="line">    sys</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用main函数之前在调试-窗口-调用堆栈，中可以看到main函数是在mainCRTStartup被调用，这个过程要为函数开辟栈空间，这块栈空间我们称为函数栈帧。栈帧需要ebp和esp两个寄存器，在函数调用的过程中这两个寄存器存放了维护这个栈的栈底和栈顶指针。在汇编窗口可以看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">push   ebp</span><br><span class="line">mov    ebp,esp</span><br><span class="line">sub    esp, 0E4h</span><br><span class="line">push   ebx</span><br><span class="line">push   esi</span><br><span class="line">push   edi</span><br><span class="line">lea    edi, [ebp - 0E4h]</span><br><span class="line">mov    ecx, 39h</span><br><span class="line">mov    eax, 0CCCCCCh</span><br><span class="line">rep    stos    dword ptr es:[edi]</span><br></pre></td></tr></table></figure>



<p>1.压栈，把ebp放入栈顶，而esp始终指向栈顶</p>
<p>2.将esp值传给ebp，也就是让esp,ebo移到一起</p>
<p>3.sub为减的意思，即将esp-0E4h赋给esp,且函数调用分配由高地址向低地址增长，因此esp向上移动，即开辟了新空间，也就是为main函数开辟空间。</p>
<p>4.三个push压栈分别将ebx，esi,edi按顺序压入栈顶，而esp也会指向栈顶</p>
<p>5.lea指令，加载有效地址；将ebp-0E4h的地址放入edi中，也就是edi指向ebp-0E4h，把39h放到ecx中，把0ccccccch放在eax中；</p>
<p>从edi所指向的地址开始向高地址进行拷贝，拷贝的次数为ecx内容，拷贝的内容为eax内…</p>
<h2 id="栈帧的总结"><a href="#栈帧的总结" class="headerlink" title="栈帧的总结"></a><strong>栈帧的总结</strong></h2><p>1.堆栈是C语言程序运行时必须的一个记录调用路径和参数的空间：</p>
<p>函数调用框架；</p>
<p>传递参数；</p>
<p>保存返回地址；</p>
<p>提供局部变量空间；</p>
<p>2.堆栈寄存器和堆栈操作</p>
<p>堆栈相关的寄存器</p>
<p>esp,堆栈指针（stack pointer）</p>
<p>ebp,基址指针（base pointer）</p>
<p>堆栈操作</p>
<p>push 栈顶地址减少4个字节（32位）</p>
<p>pop 栈顶地址增加4个字节</p>
<p>ebp在C语言中用作记录当前函数调用基址</p>
<hr>
<p>表面上：</p>
<p>调用函数大连路边上浅层解释的步骤是：</p>
<p>1.通过函数名找到函数入口地址</p>
<p>2.给形参分配空间</p>
<p>3.传值：把实参变量对应内存空间的值传递给形参变量对应的空间</p>
<p>4.执行函数体语句</p>
<p>5.函数返回值并释放函数空间</p>
<p>在函数参数传递的过程中如何确定传值和传地址：</p>
<p>当只读（只使用不修改）实参变量的值时，传实参变量名；</p>
<p>当写（既使用也修改）实参变量对应内存空间的值，传实参变量对应内存空间的地址。</p>
<hr>
<p>另一种解释：</p>
<p>当一个程序开始运行时，他的代码被装入到内存，保存在代码区，包括主函数和其他函数的代码。另外，还有三块内存区域用来存放数据。第一块是全局变量区域，存放了程序当中的所有全局变量。由于全局变量的个数和大小是已知的，所以这一块区域所占用的内存大小在开始即可确定下来，它们被称为是静态分配。位于此区域内的变量，它们在程序的整个运行过程中，都一直存在，只有当整个程序运行结束了，这一块内存区域才会释放。第二块区域是栈区域，包含了所有的栈帧，所谓的栈帧就是在调用一个函数时，系统会自动分配一块内存区域给这个函数，用来保存它的运行上下文、形参和局部变量等信息，这样的一块内存区域，就叫做栈帧。栈帧是在函数调用时分配的，当函数调用结束后，相应的栈帧就会被释放。所以，对于一个函数的局部变量来说，只有当函数调用发生时，系统才会给这个函数的形参和局部变量分配存储空间；当函数调用结束后，这些局部变量就被释放了。另外，由于栈区域是由系统自动来分配的，用户并不需要去关心，所以也称为是自动分配。第三块区域是堆区域，他主要是用作动态分配的内存。</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">SIDPUAPI <span class="keyword">void</span> <span class="title">SVPHB</span><span class="params">(SVPHBAlg* pAlg)</span></span></span><br></pre></td></tr></table></figure>

<p>extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern “C”后，会指示编译器这部分代码按C语言（而不是C++）的方式编译。</p>
<h3 id="可重入函数和不可重入函数"><a href="#可重入函数和不可重入函数" class="headerlink" title="可重入函数和不可重入函数"></a><strong>可重入函数和不可重入函数</strong></h3><p>在函数中如果我们使用静态变量了，导致产生中断调用别的函数的过程可能还会调用这个函数，于是原来的静态变量被这里改变了，然后返回主体函数</p>
<h2 id="Kconfig-Makefile和-config"><a href="#Kconfig-Makefile和-config" class="headerlink" title="Kconfig,Makefile和.config"></a><strong>Kconfig,Makefile和.config</strong></h2><p>Makefile : 一个文本形式的文件，其中包含一些规则告诉make编译哪些文件以及怎样编译这些文件，</p>
<p>Kconfig：一个文本形式的文件，其中主要作用是在内核配置时候，作为配置选项。</p>
<p>.config:文件是在进行内核配置的时候，经过配置后生成的内核编译参考文件。</p>
<h2 id="Kconfig"><a href="#Kconfig" class="headerlink" title="Kconfig"></a>Kconfig</h2><p>一个典型的内核配置菜单如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu <span class="string">"Network device support"</span></span><br><span class="line"><span class="built_in">config</span> NETDEVICES</span><br><span class="line">	<span class="keyword">bool</span> <span class="string">"Enable Net Devices"</span></span><br><span class="line">    depends on NET</span><br><span class="line">    defailt y</span><br><span class="line">    help</span><br><span class="line">    	This is help desciption.</span><br><span class="line">...</span><br><span class="line"><span class="built_in">end</span> menu</span><br></pre></td></tr></table></figure>

<p>包含在menu/endmenu中的内容会成为Network device support的子菜单。每个子菜单项都是由config来定义的。config下方的那些bool, depends on,help等为config的属性，用于定义该菜单的类型、依赖项、默认值、帮助信息等。</p>
<p>2、补充说明一下类型定义部分</p>
<p>每个config菜单项都要有类型定义：bool布尔类型，tristate三态（内建，模块，移除）、string字符串、hex十六进制、integer整型。</p>
<p>例如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">config</span> HELLO_MODULE</span><br><span class="line"><span class="keyword">bool</span> <span class="string">"hello test module"</span></span><br></pre></td></tr></table></figure>

<p>bool类型的只能选中或不选中，显示为[]；tristate类型的菜单项多了编译成内核模块的选项，显示为&lt;&gt;，假如选中内建，就是直接编译成内核影响，就会在.config中生成一个CONFIG_HELLO_MODULE=m的配置，假如选择内建，就是直接编译成内核影响，就会在.config中生成一个CONFIG_HELLO_MODULE=y的配置，hex十六进制类型显示为（）。</p>
<p>3、目录层次迭代</p>
<p>在Kconfig中有类似语句：source “divers/usb/Kconfig”</p>
<p>用来包含（或嵌套）新的Kconfig文件，这样便可以使各个目录管理各自的配置内容，使不必把那些配置都写在同一文件里，方便修改和管理。</p>
<hr>
<h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a><strong>Makefile</strong></h3><p>2.6内核的Makefile分为5个组成部分：</p>
<p>1.最顶层的Makefile</p>
<p>2.内核的.config配置文件</p>
<p>3.在arch/$(ARCH)目录下的体系结构相关的Makefile</p>
<p>4.在s目录下的Makefile.*文件，是一些Makenfile的通用规则</p>
<p>5.各级目录下的大概约500个kbuild Makefile文件</p>
<p>顶层的Makefile文件读取.config文件的内容，并总体上负责build内核和模块。Arch Make则提供补充体系结构相关的信息。s目录下的Makefile文件包含了所有用来根据kbuild Makefile构建内核所需的定义和规则。</p>
<p>Kuild Makefile核心内容是：</p>
<p>1.目标定义</p>
<p>目标定义是用来定义哪些内容要做为模块编译，哪些要编译连接进内核。</p>
<p>obj-y += foo.o</p>
<p>表示要由foo.c或者foo.s文件编译到得到foo.o并连接进内核，而obj-m则表示该文件要作为模块编译。除了y,m以外的obj-x形式的目标都不会被编译。而更常见的做法是根据.config文件的CONFIG_变量来决定文件的编译方式。如：</p>
<p>obj-$(CONFIG_EXT2) += ext2.o</p>
<p>除了Obj-形式的目标以外，还有lib-y library 库，hostprogs-y主机程序等目标，但是基本都应用在特定的目录和场合下。</p>
<hr>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200721131854374.png" alt="image-20200721131854374"></p>
<p>上面是有问题的程序</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  
  
  

</article>
    
    <article id="post-深度学习" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/07/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"
    >深度学习</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/07/07/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2020-07-07T02:52:22.000Z" itemprop="datePublished">2020-07-07</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h2 id="深度学习专业术语"><a href="#深度学习专业术语" class="headerlink" title="深度学习专业术语"></a><strong>深度学习专业术语</strong></h2><p>conv 3-64       (三个通道图片，64个卷积核)</p>
<p>卷积核：就是处理图像时，给定输入图像，输入图像中一个小区域中像素加权平均后成为输出图像中的每个对应像素，其中权值由一个函数定义，这个函数成为卷积核。</p>
<p>卷积核具有一个属性就是局部性，只关注局部特征，局部的程度取决于卷积核的大小。也可以另外一个角度理解卷积的意义，学过信号处理的，时域卷积对应频域相乘，所以原图像与卷积核的卷积其实是对频域信息进行选择。</p>
<h3 id="VGG16网络结构"><a href="#VGG16网络结构" class="headerlink" title="VGG16网络结构"></a><strong>VGG16网络结构</strong></h3><p>用池化层作为分界，VGG16共有6个块结构，每个块结构中的通道数相同。因为卷积层和全连接层都有权重系数，也被称为权重层，其中卷积层13，全连接层3层，池化层不涉及权重。总共13+3=16层。</p>
<p>对于VGG16卷积神经网络而言，其13层卷积层和5层池化层负责进行特征的提取，最后的的3层全连接层负责完成分类。</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200707135033922.png" alt="image-20200707135033922"></p>
<p><strong>VGG16的卷积核</strong></p>
<p>卷积层都是3*3的卷积核，conv3-xxx表示，xxx表示通道数。其步长为1，用padding=same填充。</p>
<p>池化层的池化核为2*2.</p>
<p>MaxPooling的作用</p>
<p>1.不变性，包括平移，旋转，尺度</p>
<p>2.保留主要的特征同时减少参数（降维，效果类似PCA）和计算量，防止过拟合，提高模型泛化能力。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  
  
  

</article>
    
    <article id="post-C-常用的东西" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/06/C-%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%9C%E8%A5%BF/"
    >C++常用的东西</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/07/06/C-%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%9C%E8%A5%BF/" class="article-date">
  <time datetime="2020-07-06T08:31:07.000Z" itemprop="datePublished">2020-07-06</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h3 id="inline"><a href="#inline" class="headerlink" title="inline"></a><strong>inline</strong></h3><p>C++关键字，函数返回类型前加inline,即可以把函数指定为内联函数。这样可以解决一些频繁调用的函数大量消耗栈空间（栈内存）的问题。关键字inline必须与函数定义放在一起才能使函数成为内联函数。是一种“用于实现”的关键字。</p>
<p>：：</p>
<p>表示作用域，和所属关系。比如一个A类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	pulic:</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在一个函数test属于A</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">A::test</span><span class="params">()</span>    <span class="comment">//表示test是属于A的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>::是运算符中等级最高的，它分为三种：</p>
<ul>
<li><p>全局作用符，（：：name）</p>
</li>
<li><p>类作用域符，（class :: name）</p>
</li>
<li><p>命名空间作用域符 ， 用法（namespace :: name）</p>
</li>
</ul>
<p>：</p>
<ul>
<li><p>类名后加冒号用来定义类的继承</p>
</li>
<li><p>构造函数后加冒号是初始化表达式：比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iStack(<span class="keyword">int</span> capacity) : _stack(capacity), _top(<span class="number">0</span>)&#123;&#125;</span><br><span class="line"><span class="comment">//冒号后面的内容是初始化类的数据成员_top;_stak;</span></span><br><span class="line"><span class="comment">//也这样写;</span></span><br><span class="line">iStack(<span class="keyword">int</span> capacity)</span><br><span class="line">&#123;</span><br><span class="line">	_stack(capacity);</span><br><span class="line">	_top(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>表示机构内位域的定义（即该变量占几个bit空间）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> struct_XXX&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> a:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> c;</span><br><span class="line">&#125;; XXX</span><br></pre></td></tr></table></figure>
</li>
<li><p>用于public和privare后，表示后面的所有成员是公有或者私有；</p>
</li>
</ul>
<h3 id="pragma-pack"><a href="#pragma-pack" class="headerlink" title="#pragma pack"></a><strong>#pragma pack</strong></h3><p>语法： #pragma pack([sow] | [push | pop] [,identifier], n)</p>
<p>pack为struct,union和class等的成员对齐指定字节边界。</p>
<ul>
<li><p>#pragma pack(n)       将当前字节对齐值设为n</p>
</li>
<li><p>#pragma pack()    将当前字节对齐值设备默认值（通常是8） </p>
<p>…</p>
</li>
</ul>
<h3 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a><strong>对齐</strong></h3><p>各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对齐数据存放进行对齐，会在存取效率上带来损失。</p>
<p><strong>结构体对齐规则</strong></p>
<p>结构体中各个成员按照它们被声明的顺序在内存中顺序存储；</p>
<p>1）将结构体内所有数据成员的长度值相加，记为sum_a;</p>
<p>2）将各数据成员内存对齐，按各自对齐模数而填充的字节数累加到和sum_a上，记为sum_b。对齐模数是【该数据成员所占内存】与【#pragma pack指定的数值】中的较小者。</p>
<p>3）将和sum_b向结构体模数对齐，该模数是【#pragma pack指定的数值】、【未指定#pragma pack时，系统默认的对齐模数8字节】和【结构体内部最大的基本数据类型成员】长度中数值较小者。结构体的长度应该是该模数的整数倍。</p>
<h3 id="基本数据类型所占内存大小"><a href="#基本数据类型所占内存大小" class="headerlink" title="基本数据类型所占内存大小"></a><strong>基本数据类型所占内存大小</strong></h3><table>
<thead>
<tr>
<th></th>
<th>char</th>
<th>bool</th>
<th>short</th>
<th>int</th>
<th>unsigned int</th>
<th>float</th>
<th>long</th>
<th align="center">double</th>
<th>long long</th>
<th>long double</th>
<th>指针</th>
</tr>
</thead>
<tbody><tr>
<td>32bit编译器</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td align="center">8</td>
<td>8</td>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td>64bit编译器</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>8</td>
<td align="center">8</td>
<td>8</td>
<td>8</td>
<td>8</td>
</tr>
</tbody></table>
<p>按32bit编译器处理为例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> c;        <span class="comment">//1  </span></span><br><span class="line">	short sh;      <span class="comment">//2 </span></span><br><span class="line">	<span class="keyword">int</span> a;         <span class="comment">//4</span></span><br><span class="line">	<span class="keyword">float</span> f;       <span class="comment">//4</span></span><br><span class="line">	<span class="keyword">int</span> *p;        <span class="comment">//</span></span><br><span class="line">	<span class="keyword">char</span> *s;</span><br><span class="line">	<span class="keyword">double</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总共占28Bytes，c的偏移量为0，占1Byte, sh占2Byte, 它的对齐模数是2（2&lt;4,取小者），存放起始地址应该是2的整数倍，因此c后填充1个空字符，sh的起始地址是2。a占4Byte,对齐模式是4，因此在sh后存放即可，偏移量为4。f占4个字节，对齐模式是4，存放地址是4的整数倍，起始地址是8。p,s的起始地址分别是12,16.d占8个字节，对齐模式是4（4&lt;8）,d从偏移地址为20处存放。存放后结构体占28个字节，是4的整数倍不用补空字符。</p>
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>C</td>
<td>null</td>
<td>sh</td>
<td>sh</td>
</tr>
<tr>
<td>2</td>
<td>a</td>
<td>a</td>
<td>a</td>
<td>a</td>
</tr>
<tr>
<td>3</td>
<td>f</td>
<td>f</td>
<td>f</td>
<td>f</td>
</tr>
<tr>
<td>4</td>
<td>p</td>
<td>p</td>
<td>p</td>
<td>p</td>
</tr>
<tr>
<td>5</td>
<td>s</td>
<td>s</td>
<td>s</td>
<td>s</td>
</tr>
<tr>
<td>6</td>
<td>d</td>
<td>d</td>
<td>d</td>
<td>d</td>
</tr>
<tr>
<td>7</td>
<td>d</td>
<td>d</td>
<td>d</td>
<td>d</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">	<span class="keyword">double</span> d;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	short sh;</span><br><span class="line">	<span class="keyword">float</span> f;</span><br><span class="line">	<span class="keyword">int</span> *p;</span><br><span class="line">	<span class="keyword">char</span> *s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>c</td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>2</td>
<td>d</td>
<td>d</td>
<td>d</td>
<td>d</td>
</tr>
<tr>
<td>3</td>
<td>d</td>
<td>d</td>
<td>d</td>
<td>d</td>
</tr>
<tr>
<td>4</td>
<td>a</td>
<td>a</td>
<td>a</td>
<td>a</td>
</tr>
<tr>
<td>5</td>
<td>sh</td>
<td>sh</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>6</td>
<td>f</td>
<td>f</td>
<td>f</td>
<td>f</td>
</tr>
<tr>
<td>7</td>
<td>p</td>
<td>p</td>
<td>p</td>
<td>p</td>
</tr>
<tr>
<td>8</td>
<td>s</td>
<td>s</td>
<td>s</td>
<td>s</td>
</tr>
</tbody></table>
<p><strong>函数是什么</strong></p>
<p><strong>函数的调用过程</strong></p>
<p>在c语言中到某一个函数时，它就会跳转过去执行这个函数，执行完毕后接着再去执行下一条指令。在执行调用函数的过程中，计算机通常还要根据函数完成一些工作，这些操作通过形成一个栈帧来完成。栈帧是编译器用来实现函数调用过程的一种数据结构。C语言中，每个栈帧对应着一个未运行完的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在数据结构中, 栈是限定仅在表尾进行插入或删除操作的线性表。栈是一种数据结构，它按照后进先出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据。</span><br></pre></td></tr></table></figure>
















      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  
  
  

</article>
    
    <article id="post-Linux命令" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/06/Linux%E5%91%BD%E4%BB%A4/"
    >Linux命令</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/07/06/Linux%E5%91%BD%E4%BB%A4/" class="article-date">
  <time datetime="2020-07-06T06:21:48.000Z" itemprop="datePublished">2020-07-06</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a><strong>pwd</strong></h3><p>显示当前的工作目录，执行pwd指令可立刻知道目前所在的工作目录的绝对路径名称；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure>

<h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a><strong>rm</strong></h3><p>用来删除某个目录及其下的所有文件及其子目录。对于链接文件，只是断了链接，原文件保持不变。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm [选项] 文件或目录</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>选项</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td>-r</td>
<td align="left">将选型中列出的全部目录以及子目录还有文件均递归地删除，如果在选项中不指定“-r”选项，“rm”命令将不能删除目录</td>
</tr>
<tr>
<td>-f</td>
<td align="left">忽略不存在的问题，也不给提示</td>
</tr>
<tr>
<td>-i</td>
<td align="left">交互式删除，即在删除前进行确认</td>
</tr>
</tbody></table>
<blockquote>
<p>使用“rm-rf”组合要谨慎，因为文件一旦被删除，就不能恢复。rm的“-i”选项需要输入y，文件才被删除，输入其他信息不被删除。</p>
</blockquote>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  
  
  

</article>
    
    <article id="post-破解AD14软件的步骤" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/06/%E7%A0%B4%E8%A7%A3AD14%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%AD%A5%E9%AA%A4/"
    >破解AD14软件的步骤</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/07/06/%E7%A0%B4%E8%A7%A3AD14%E8%BD%AF%E4%BB%B6%E7%9A%84%E6%AD%A5%E9%AA%A4/" class="article-date">
  <time datetime="2020-07-06T01:36:06.000Z" itemprop="datePublished">2020-07-06</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>找到解压文件的Mechine，将DXP文件复制替换到软件安装的文件夹中，双击DXP文件，然后</p>
<p>在Add standalone license file位置点击</p>
<p> <img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200706094202521.png" alt="image-20200706094202521"></p>
<p>在License 文件中选任意一个破解文件即可。</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200706094301758.png" alt="image-20200706094301758"></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  
  
  

</article>
    
    <article id="post-Linux" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/06/26/Linux/"
    >Linux</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/06/26/Linux/" class="article-date">
  <time datetime="2020-06-26T10:07:12.000Z" itemprop="datePublished">2020-06-26</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h2 id="Linux-驱动开发"><a href="#Linux-驱动开发" class="headerlink" title="Linux 驱动开发"></a><strong>Linux</strong> <strong>驱动开发</strong></h2><h3 id="Linux操作系统与驱动的关系"><a href="#Linux操作系统与驱动的关系" class="headerlink" title="Linux操作系统与驱动的关系"></a>Linux操作系统与驱动的关系</h3><p>应用程序一般依赖于函数库，而函数库是由系统调用来编写的，所以应用程序间接地依赖于系统调用。</p>
<p>系统调用层是内核空间和用户空间的接口层。通过这个系统调用层，应用程序不需要直接访问内核空间的程序，增加了内核的安全性。同时，应用程序也不能访问硬件设备，只能通过系统调用层来访问硬件设备。如果应用程序需要访问硬件设备，那么应用程序先访问系统调用层，由系统调用层去访问内核层的设备驱动程序。</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200626184242247.png" alt="image-20200626184242247"></p>
<h3 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a><strong>用户态和内核态</strong></h3><p>Linux操作系统分为<strong>用户态</strong>和<strong>内核态</strong>。用户态处理上层的软件工作。内核态用来管理用户态的程序，完成用户态请求的工作。驱动程序与底层的硬件交互，所以工作在内核态。</p>
<p>Linux操作系统分为两个状态的原因主要是，为应用程序提供一个统一的计算机硬件抽象。工作在用户态的应用程序完全可以<strong>不考虑底层</strong>的硬件操作，这些操作由内核态程序来完成。这些内核态程序大部分是<strong>设备驱动程序</strong>。一个好的操作系统的驱动程序对用户态应用程序应该是透明的，也就是说，应用程序可以在不了解硬件工作原理的情况下，很好地操作硬件设备，同时不会使硬件设备进入非法状态。Linux操作系统很好的做到了这一点。</p>
<p>另一个值得注意的问题是：用户态和内核态是可以相互转换的。每当应用程序执行系统调用或者被硬件中断挂起时，Linux操作系统都会从用户态切换到内核态。当系统调用完成或者中断处理完成后，操作系统会从内核态返回用户态，继续执行应用程序。</p>
<h3 id="模块机制"><a href="#模块机制" class="headerlink" title="模块机制"></a><strong>模块机制</strong></h3><p>模块是可以在运行时加入内核的代码。Linux支持很多种模块，驱动程序就是其中最重要的一种，甚至文件系统也可以写成一个模块，然后加入内核中。</p>
<p>模块在内核启动时装载称为静态装载，在内核已经运行时装载称为动态装载。模块可以扩充内核所期望的任何功能，但通常用于实现设备驱动程序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">int_init <span class="title">xxx_init</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*模块加载时的初始化工作*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> _exit <span class="title">xxx_exit</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*模块卸载时的销毁工作*/</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(xxx_init);    <span class="comment">//指定模块的初始化函数的宏</span></span><br><span class="line">module_exit(xxx_exit);    <span class="comment">//指定模块的卸载函数的宏</span></span><br></pre></td></tr></table></figure>

<p>在Linux上程序开发一般分为两种，一种是内核及驱动程序开发，另一种是应用程序开发。这两种开发种类对应Linux的两种状态，分别是内核态和用户态。内核态用来管理用户态的程序，完成用户态请求的工作；用户态的处理上层的软件工作。驱动程序与底层的硬件交互，所以工作在内核态。</p>
<p>内核及驱动开发时必须使用GNU C，因为Linux操作系统从一开始就使用的是GNU C，虽然也可以使用其他的编译工具，但是需要对以前的代码做大量的修改。</p>
<h3 id="Source-Insight"><a href="#Source-Insight" class="headerlink" title="Source Insight"></a><strong>Source Insight</strong></h3><p>是一款很实用的编译器，下面介绍如何使用。</p>
<p>建立新工程；Project  -&gt; new Project</p>
<p>名字和工程名字一样，目录选择代码所在的目录。勾上冒出的两个选项，include top level sub..和Recursively add …两个分别表示，加入第一层子目录中的文件和递归的加入所有子目录中的文件。OK后colse就新建完成。</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200701154504160.png" alt="image-20200701154504160"></p>
<p>如果出现一片白，view-&gt;reset…,网上说还可以Ctr+o，出现文件目录。</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200701155120154.png" alt="image-20200701155120154"></p>
<p>Sourceinsight还可以为所有源文件建立函数、变量关系。这些关系会存储在工程对应的数据库中。小工程系统会自动创建，但是工程比较大比如一个Linux系统的工程需要手动创建。</p>
<p>Project-&gt;Sysnchronize Files, 选择Force all files to re-parsed</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200701155545694.png" alt="image-20200701155545694"></p>
<p>之后可以按住ctril+点击使用函数的地方，会自动跳转到定会函数的位置。</p>
<h2 id="Linux内核子系统"><a href="#Linux内核子系统" class="headerlink" title="Linux内核子系统"></a><strong>Linux内核子系统</strong></h2><p>这些子系统包括：进程管理、内存管理、文件管理、设备管理和网络管理。</p>
<h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a><strong>进程管理</strong></h3><p>是操作系统分配资源的基本单位，也是CPU调度的基本单位。可以给进程这样的定义：进程是程序运行的一个实例，是操作系统分配资源和调度的一个基本单位。Linux将进程分为就绪状态、执行状态和阻塞状态三个状态。linux内核负责对这三种状态进行管理。</p>
<p><strong>就绪状态</strong>：在这种状态中，进程具有处理器外的其他资源，进程不运行。当处理器空闲时，进程就被调度来运行。</p>
<p><strong>执行状态</strong>：进程处于就绪状态后，获得处理器资源，就能进入执行状态，此时程序正在运行。</p>
<p><strong>阻塞状态</strong>：进程因为等待某种事物的发生而暂时不能运行。这些事件如设备终端，其他进程的信号。</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200701191715081.png" alt="image-20200701191715081"></p>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a><strong>内存管理</strong></h3><p>内存是计算机的主要资源之一，可以将内存理解为一个线性的存储结构。用来管理内存的策略是决定系统性能的主要因素。内核在有限的资源上为每一个进程创建一个虚拟地址空间，并对虚拟地址空间进行管理。为了方便内存的管理，内核提供了一些重要的函数。这些函数包括kmalloc(),kfree()等。另外设备驱动程序需要使用内存分配，不同的分配方式对驱动程序的影响不同，所以需要对内存分配有比较清晰的了解。</p>
<h3 id="Linux源代码分析"><a href="#Linux源代码分析" class="headerlink" title="Linux源代码分析"></a>Linux源代码分析</h3><p>Linux源代码以目录的方式组织，每一个目录中有相关的内核代码。</p>
<p><strong>arch目录</strong></p>
<p>arch目录中包含与体系结构相关的代码，每一种平台都有一种相应的目录；</p>
<p><strong>drive</strong></p>
<p>目录中包含了Linux内核支持的大部分驱动程序。每种驱动程序都占用一个子目录。目录中包含了驱动的大部分代码、</p>
<p><strong>fd目录</strong></p>
<p>包含了Linux所支持的所有文件系统相关的代码。每个子目录中包含一种文件系统。</p>
<p><strong>其他目录</strong></p>
<table>
<thead>
<tr>
<th>目录或者文件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>include</td>
<td>该目录包含编译内核西药的大部分头文件，其子目录/include/linux中，包含与凭他无关的头文件，与平台有关的头文件放在各自的单独目录中。</td>
</tr>
<tr>
<td>init</td>
<td>内核的初始化代码，包含系统启动的main()函数</td>
</tr>
<tr>
<td>ipc</td>
<td>该目录最核心的代码包括进程调度、内存管理等</td>
</tr>
<tr>
<td>kernel</td>
<td>内核最核心的代码，包括进程调度、内存管理等</td>
</tr>
<tr>
<td>lib</td>
<td>该目录包含库模块代码</td>
</tr>
<tr>
<td>mm</td>
<td>该目录包含独立于CPU体系结构的内存管理代码。不同的平台的代码在该目录下有相应的目录。</td>
</tr>
<tr>
<td>net</td>
<td>包含各种网络协议</td>
</tr>
<tr>
<td>scripts</td>
<td>包含一些脚本文件，内核配置相关的文件</td>
</tr>
<tr>
<td>security</td>
<td>一个SELinux模块</td>
</tr>
<tr>
<td>sound</td>
<td>常用的音频设备驱动程序</td>
</tr>
<tr>
<td>ust</td>
<td>一个cpio</td>
</tr>
<tr>
<td>block</td>
<td>块设备驱动程序</td>
</tr>
<tr>
<td>crypto</td>
<td>常用的加密和压缩算法</td>
</tr>
<tr>
<td>Documentation</td>
<td>内核部分功能的解释文档</td>
</tr>
<tr>
<td>COPYING</td>
<td>GPL版权声明文件</td>
</tr>
<tr>
<td>CREDITS</td>
<td>内核开发者列表，包含对Linux做出很大贡献的人信息</td>
</tr>
<tr>
<td>Kbuild</td>
<td>用来编译内核的脚本</td>
</tr>
<tr>
<td>MAINTAINERS</td>
<td>维护人员列表</td>
</tr>
<tr>
<td>Makefile</td>
<td>第一个Makefile文件，用来组织内核的各个模块，记录了各个模块相互之间的联系。编译器根据这个文件来编译内核</td>
</tr>
<tr>
<td>Readme</td>
<td>内核及编译方法的介绍</td>
</tr>
<tr>
<td>REPORTING-BUG</td>
<td>关于bug的一些内容</td>
</tr>
</tbody></table>
<h3 id="内核配置选项"><a href="#内核配置选项" class="headerlink" title="内核配置选项"></a><strong>内核配置选项</strong></h3><p>配置编译过程</p>
<blockquote>
<p><strong>Makefile文件</strong>：它的作用是根据配置的情况，构造出需要编译的源文件列表，然后分别编译，并把目标代码连接在一起，最终形成Linux内核二进制文件。由于Linux内核源代码是按照树形结构组织的，所以Makefile也被分布在目录树中。</p>
</blockquote>
<blockquote>
<p><strong>Kconfig文件</strong>：它的作用是为用户提供一个层次化的配置选项集。make menuconfig 命令通过分布在各个子目录中的Kconfig文件构建配置用户界面。</p>
</blockquote>
<blockquote>
<p><strong>配置文件（.config）</strong>：当用户配置完后，将配置信息保存在.config文件中</p>
</blockquote>
<blockquote>
<p><strong>配置工具</strong>：包括配置命令解释器（对配置脚本中使用的配置命令进行解释）和配置用户界面（提供基于字符界面、基于Ncurses图像界面以及基于Xwindows图形界面的用户配置界面，各自对应于Make config、Make menuconfig和make xconfig）</p>
</blockquote>
<h2 id="嵌入式文件系统基础知识"><a href="#嵌入式文件系统基础知识" class="headerlink" title="嵌入式文件系统基础知识"></a><strong>嵌入式文件系统基础知识</strong></h2><p>除了一个嵌入式操作系统外还需要一个嵌入式文件系统管理和存储数据和程序。</p>
<p><strong>嵌入式文件系统</strong></p>
<p>Linux支持多种文件系统，包括ext2,ext3,vfat,ntfs,iso9660,jffs,romfs,cramfs和nfs等，为了对各类文件系统进行统一管理，Linux引入了虚拟文件系统VFS(Virtual File System)，为各类文件系统提供一个统一的操作界面和应用编程接口。</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702150909908.png" alt="image-20200702150909908"></p>
<p>用户层为用户提供一个操作接口，内核层实现了各种文件系统，驱动层是块设备的驱动程序，硬件层是嵌入式系统使用的几种存储器。</p>
<p>在Linux文件系统结构中，内核层的文件系统是必须的。Linux启动时，第一个必须挂载的是根文件系统；若系统不能从指定设备上挂载根文件系统，则系统会出错而退出启动。当根文件系统挂载成功后，才可以自动或手动挂载其他的文件系统。因此，一个系统中可以同时存在不同的文件系统。</p>
<p><strong>根文件系统概述</strong></p>
<p>是Linux操作系统运行需要的文件系统，根文件系统被存储在Flash存储器中，存储器被分为多个区。</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>bin</td>
<td>该目录存放用户可以使用的基本命令，bin目录下常用的命令有：cat、chmod、cp、ls、kill、mount、unmount、mkdir、mknod、test等</td>
</tr>
<tr>
<td>sbin</td>
<td>该目录下存放必要的系统管理员命令，这些命令只有系统管理员才能使用。sbin目录下存放的是基本的系统命令，它们用于启动系统、修复系统。sbin目录下常用的命令有shutdown、reboot、fdisk、fsck等</td>
</tr>
<tr>
<td>boot</td>
<td>该目录下包含引导加载程序使用的静态文件</td>
</tr>
<tr>
<td>root</td>
<td>根目录的目录，与此对应，普通用户的目录是/home下的一个子目录</td>
</tr>
<tr>
<td>home</td>
<td>用户目录。对于每一个普通用户,在/home目录下都有一个与用户名同的子目录，里面存放用户相关的配置文件和私有文件。</td>
</tr>
<tr>
<td>etc</td>
<td>该目录下存放各种系统配置文件。该目录中的文件或者子目录依赖于系统中拥有的应用程序，很多应用程序需要配置文件。</td>
</tr>
<tr>
<td>dev</td>
<td>设备文件和一些特殊文件。常见的设备文件一般有字符设备文件和块设备文件</td>
</tr>
<tr>
<td>opt</td>
<td>该目录包含附加的软件</td>
</tr>
<tr>
<td>mnt</td>
<td>临时文件系统的挂接目录，用来挂接暂时需要到的文件系统。如挂接光盘、U盘和硬盘</td>
</tr>
<tr>
<td>lib</td>
<td>该目录中存放共享库和一些驱动程序模块。共享库用于对/bin,/sbin中的程序进行支持</td>
</tr>
<tr>
<td>proc</td>
<td>该目录是一个空目录，作为proc文件系统的挂接点。proc文件系统时一个虚拟的文件系统，它存在于内存中。proc文件系统中的目录和文件系统都是内核临时生成的，用于了解系统目前的运行状态。</td>
</tr>
<tr>
<td>tmp</td>
<td>该目录通常是一个空目录，用于存放临时文件。一些需要存放临时文件的程序会用到/tmp目录，所以该目录必须存在</td>
</tr>
<tr>
<td>usr</td>
<td>该目录中存放共享、只读的文件和程序。该目录中的文件可以被多个用户共享</td>
</tr>
<tr>
<td>var</td>
<td>存放可变的文件。例如日志文件、log文件、临时文件等</td>
</tr>
</tbody></table>
<p><strong>BusyBox构建根文件系统</strong></p>
<p>是一个用来构建根文件系统的工具。最初的目的是自动构建一个能够在软盘上运行的命令系统。他可以把常用的Linux命令打包编译成一个单一的可执行文件。通过建立连接，用户可以像传统的命令一样使用BusyBox。</p>
<p>下载<a href="http://www.busybox.net/downloads" target="_blank" rel="noopener">http://www.busybox.net/downloads</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar jxvf Busybox 1.2.0.tar.bz2</span><br></pre></td></tr></table></figure>

<p>进入Busybox源代码所在的目录，命令进行配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>











<h2 id="构建第一个驱动程序"><a href="#构建第一个驱动程序" class="headerlink" title="构建第一个驱动程序"></a><strong>构建第一个驱动程序</strong></h2><p>构建正确的开发环境，对写驱动程序非常重要。</p>
<p>内核是一个提供硬件抽象层、磁盘及文件系统控制、多任务等功能的系统软件。根据内核是否被修改过，可以将内核分为标准内核和厂商内核两类。</p>
<p>如何升级内核</p>
<p>1.从<a href="http://www.kernel.org/pub/linux/kernel/" target="_blank" rel="noopener">http://www.kernel.org/pub/linux/kernel/</a> 上下载linux-2.6.29.4.tar.bz2内核源码包</p>
<p>2.使用mkdir linux-2.6.29.4在根目录中建立一个目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir linux-2.6.29.4</span><br></pre></td></tr></table></figure>

<p>3.将Linux-2.6.29.4.tar.bz2复制到/linux-2.6.29.4目录中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp linux-2.6.29.4.tar.bz2 &#x2F;linux-2.6.29.4&#x2F;</span><br></pre></td></tr></table></figure>

<p>4.进入该目录，用tar-xjvf解压</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd linux-2.6.29.4</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xjvf linux-2.6.29.4.tar.bz2</span><br></pre></td></tr></table></figure>



<ol start="5">
<li>进入第二层内核源码目录，cd linux-3.6.29.4</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd linux-2.6.29.4</span><br></pre></td></tr></table></figure>

<p>6.执行make menconfig配置内核并保存</p>
<p>7.编译内核make命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<p>8.编译内核模块 make modules</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make modules</span><br></pre></td></tr></table></figure>

<p>9.安装内核模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make modules_install</span><br></pre></td></tr></table></figure>

<p>10.安装内核</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>11.使用reboot重启计算机，选择新内核启动系统</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>



<h2 id="驱动模块的组成"><a href="#驱动模块的组成" class="headerlink" title="驱动模块的组成"></a><strong>驱动模块的组成</strong></h2><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702160917886.png" alt="image-20200702160917886"></p>
<p>1.头文件</p>
<p>有两个头文件是所有驱动模块都必须包含的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux&#x2F;module.h&gt;      &#x2F;&#x2F;包含了加载模块时需要使用的大量符号和函数定义</span><br><span class="line">#include &lt;linux&#x2F;init.h&gt;        &#x2F;&#x2F;包含了模块加载函数和模块释放函数的宏定义</span><br></pre></td></tr></table></figure>

<p>2.模块参数</p>
<p>是驱动模块加载时，需要传递给驱动模块的参数。如果一个驱动模块需要完成两个种功能，那么就可以通过模块参数选择哪一种功能。</p>
<p>3.模块加载函数</p>
<p>是模块加载时，需要执行的函数</p>
<p>4.模块卸载函数是模块卸载时，需要执行的函数。</p>
<p>5.模块许可声明</p>
<p>模块许可声明表示模块受内核支持的程度。有许可权的模块会更受到开发人员的重视。需要使用MODULE_LICENSE表示该模块的许可权限。</p>
<p>MODULE_LICENSE (‘’GPL’’)</p>
<p>GPL v2    //GPL版本2许可权</p>
<p>GPL and additional rights       //GPL及其附加许可权    GPL(通用公共许可证,保证您能收到源程序或者在你需要时能得到它；保证你能修改软件或者将它的一部分用于新的自由软件)</p>
<p>Dual BSD/GPL                        //*BSD/GPL双重许可权</p>
<p>Dual MPL/GPL                       //*MPL/GPL双重许可权</p>
<p>Proprietary                             //专用许可权</p>
<p>如果一个模块没有包含任何许可权，那么就会认为是不符合规范的。</p>
<p>Hello World模块</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hello_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_ALERT <span class="string">"Hello, Word\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_ALERT <span class="string">"Goodbye, World\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line">module_init(hello_init);                           <span class="comment">//指定模块加载函数</span></span><br><span class="line">module_exit(hello_exit);                           <span class="comment">//指定模块卸载函数</span></span><br><span class="line">MODULE_LICENSE(<span class="string">"Dual BSD/GPL"</span>);                    <span class="comment">//指定许可权为Dual BSD/GPL*/</span></span><br></pre></td></tr></table></figure>



<p>Makefile文件</p>
<p>编译hello world模块需要编写一个Makefile文件，首先这是一个完整的Makefile文件，以便对该文件有整体的认识。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ifeq ($(KERNELRELEASE),)</span><br><span class="line">	KERNELDIR   ?= /linux-2.6.29.4/linux-2.6.29.4</span><br><span class="line">	PWD := $(shell pwd)</span><br><span class="line">modules:</span><br><span class="line">	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules</span><br><span class="line">modules_install:</span><br><span class="line">	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules_install</span><br><span class="line">clean</span><br><span class="line">	rm -rf *.0 *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions</span><br><span class="line">else </span><br><span class="line">	obj-m := hell0.o</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<ul>
<li>第一行，判断KERNELRELEASE变量是否为空，改变量是描述内核版本的字符串。只有执行make命令的当前目录为内核源代码目录时，该变量才不为空字符。</li>
<li>第二、三行，定义了KERNELDIR、PWD变量，一个是内核路径变量，一个是由执行pwd命令得到的当前模块路径。</li>
<li>第四行，是<strong>一个标识，以冒号结尾，标识Makefile文件的一个功能选项</strong>。</li>
<li>第五行，make的语法是”Make-C 内核路径 M=模块路径 modiles”。该语句会执行内核模块的编译</li>
<li>第六行和第四行表示同样的意思</li>
<li>第七行是将模块安装到模块对应的路径中，当在命令执行make modules_install时，执行该命令，其他时候不执行。</li>
<li>第八行是删除多余的文件</li>
<li>第九行是删除编译过程的中间文件的命令。</li>
<li>第11行，是将hello.o编译成hello.ko模块。如果要编译其他模块时，只是将hello.o中的hello改成模块的文件名就可以了。</li>
</ul>
<p><strong>Makefile文件的执行过程：</strong></p>
<p>执行make命令后，将进入Makefile文件。此时KERNELRELEASE变量为空，此时是第一次进入Makefile文件。当执行完02，03行代码后，会根据make命令的参数执行不同的逻辑。</p>
<ul>
<li><p>make modules_install命令，将执行6，7行将模块安装到操作系统中；</p>
</li>
<li><p>make clean命令，会删除目录中的所有临时文件</p>
</li>
<li><p>make命令，会执行04，05行编译模块。首先</p>
</li>
<li><pre><code>$(MAKE) -C $(KERNELDIR) M=$(PWD) modules
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  -C $(KERNELDIR)会使编译器进入内核源码目录&#x2F;linux-2.6.29.4&#x2F;linux-2.6.29.4,读取Makefile文件，并从中得到一些信息，例如变量KERNELRELEASE将在这里被赋值。当内核源码目录中的Makefile文件读取完成后，编译器会根据选项 </span><br><span class="line"></span><br><span class="line">   M&#x3D;$(PWD) 第二次进入模块所在的目录，并再一次执行Makefile文件。当第二次执行Makefile文件时，变量KERNELRELEASE的值为内核发布版本信息，也就是不为空，此时会执行10，11，12行。这里的代码指明了模块源码中各文件的依赖关系，以及要生成的目标模块名，这里就正式编译模块了。</span><br><span class="line"></span><br><span class="line">**编译模块**</span><br><span class="line"></span><br><span class="line">有了Makefile文件，就可以在模块所在的目录下执行make命令，生成模块。</span><br></pre></td></tr></table></figure>
# make
make -C /linux=2.6.29.4/linux-2.6.29.4 M=/driver-test/chapter5/hello
modules
make[1]:Entering directory &apos;/linux-2.6.29.4/linux-2.6.29.4&apos;
  Building modules, stage 2.
  MODPOST 1 modules
make[1]:Leavinf directory &apos;/linux-26.29.4/linux-2.6.29.4&apos;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可看出，编译器首先进入内核源代码文件所在的目录，进入该目录的目的是生成hello.o中间文件，编译模块的第二个阶段是运行MODPOST程序，生成hello.mod.c文件，最后连接hello.o和hello.mod.c文件，生成hello.ko模块文件。</span><br><span class="line"></span><br><span class="line">## 模块与模块之间的通信</span><br><span class="line"></span><br><span class="line">## **设备驱动中的并发控制**</span><br><span class="line"></span><br><span class="line">### **并发与竞争**</span><br><span class="line"></span><br><span class="line">并发是指在操作系统中，一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，担任一个时刻点上只有一个程序在处理机上运行。并发容易导致竞争问题。竞争就是两个或两个以上的进程同时访问一个资源，从而引起资源的错误。</span><br><span class="line"></span><br><span class="line">**原子变量操作：**</span><br><span class="line"></span><br><span class="line">就是该操作绝不会再执行完毕前被任何其他任务或事件打断。也就是说，原子变量操作是一种不可以被打断的操作。原子操作需要硬件的支持，因此是架构相关的，其API和原子类型的定义在内核源码树的include&#x2F;asm&#x2F;atomic.h文件中，他们都使用汇编语言实现，因为C语言并不能实现这样的操作。</span><br><span class="line"></span><br><span class="line">原子变量操作不会只执行一半，又去执行其他代码。他要么执行完毕，那么一点也不执行。原子变量操作的优点是编写简单；缺点是功能太简单，只能做计数操作，保护东西太少，但却是其他同步手段的基石。原子变量定义：</span><br></pre></td></tr></table></figure>
typedef struct{
  volatile int counter;
}atomic_t;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">volatile用来暗示GCC不要对该类型做数据优化，所以对这个变量countrt的访问都是基于内存的，不要将其缓冲到寄存器中。存储到寄存器中，可能导致内存中的数据已经改变，而寄存器中的数据没有改变。</span><br><span class="line"></span><br><span class="line">### **自旋锁**</span><br><span class="line"></span><br><span class="line">是一种简单的并发控制机制，其是实现信号量和完成量的基础。自旋锁对资源有很好的保护作用。当一个临界区域要在多个函数之间来回运行时，原子操作就显得无能为力。</span><br><span class="line"></span><br><span class="line">Linux中一般可以认为有两种锁，一种是自旋锁，另一种是信号量。这两种锁是为了解决内核中遇到的不同问题开发的。</span><br><span class="line"></span><br><span class="line">**自旋锁的作用**</span><br><span class="line"></span><br><span class="line">自旋锁类型为struct spinlock_t ， 内核提供了一系列的函数对struct spinlock_t进行操作。</span><br><span class="line"></span><br><span class="line">1.定义和初始化自旋锁</span><br><span class="line"></span><br><span class="line">在Linux中，定义自旋锁的方法和定义普通结构体的方法相同，定义方法为</span><br></pre></td></tr></table></figure>
spinlock_t lock;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">一个自选锁必须初始化才能被使用个，对自旋锁的初始化可以在编译阶段通过宏来实现，初始化自旋锁就可以使用宏SPIN_LOCK_UNLOCKED,这个宏表示一个没有锁定的自旋锁，</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;c</span><br><span class="line">spinlock_t lock&#x3D;SPIN_LOCK_UNLOCKED    &#x2F;&#x2F;初始化一个未使用的自旋锁</span><br></pre></td></tr></table></figure>
</code></pre></li>
</ul>
<p>在运行阶段可以使用spin_lock_init(spinlock_t lock)函数动态地初始化一个自旋锁.</p>
<p><strong>锁定自旋锁：</strong></p>
<p>在进入临界区前，需要使用spin_lock宏来获得自旋锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define spin_lock(lock)      _spin_lock(lock)</span><br></pre></td></tr></table></figure>

<p>这个宏用获得lock自旋锁，如果能够立即获得自旋锁，则宏立刻返回；否则，这个锁会一直自旋在那里，直到该锁被其他线程释放为止。</p>
<p>释放自旋锁：</p>
<p>当不再使用临界区时，需要使用spin_unlock宏释放自旋锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define spin_unlock(lock)          _spin_unlock(lock)</span><br></pre></td></tr></table></figure>

<p>这个宏用来释放lock自旋锁，当调用该宏之后，</p>
<p>使用自旋锁</p>
<p>定义、初始化、获取、释放</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spinlock_t   lock;</span><br><span class="line">spin_lock_init(&amp;lock);</span><br><span class="line">spin_lock(&amp;lock);</span><br><span class="line">临界资源</span><br><span class="line">spin_unlock(&amp;lock);</span><br></pre></td></tr></table></figure>

<p>在驱动程序中，有些设备只允许打开一次，那就需要一个自旋锁保护表示设备的开关或者关闭状态的变量count，此处count属于一个临界变量，如果不对count进行保护，当设备打开频繁时，可能出现错误的count计数，所以必须对count进行保护。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">int count&#x3D;0;</span><br><span class="line">spinlock_t lock;</span><br><span class="line">int xxx_init(void)&#123;</span><br><span class="line">	...</span><br><span class="line">	spin_lock_init(&amp;lock);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;文件打开函数</span><br><span class="line">int xxx_open(struct inode *innode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	spin_lock(&amp;lock);</span><br><span class="line">	if(count)</span><br><span class="line">	&#123;</span><br><span class="line">		spin_unlock(&amp;lock);</span><br><span class="line">		return -EBUSY;</span><br><span class="line">	&#125;</span><br><span class="line">	count++;</span><br><span class="line">	spin_unlock(&amp;lock);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;文件释放函数</span><br><span class="line">int  xxx_release(struct inode *inode, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	spin_lock(&amp;lock);</span><br><span class="line">	count++;</span><br><span class="line">	spin_unlock(&amp;lock);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自旋锁的使用注意事项：</p>
<ul>
<li><p>自旋锁是一种忙等待，自旋锁当条件不满足时，会一直不断地循环条件是否满足。满足就解锁，继续运行下面代码。它是一种适合短时间锁定的轻量级的加锁机制。</p>
</li>
<li><p>自旋锁不递归使用。是因为，自旋锁被设计成在不同线程或者函数之间同步。如果一个线程在已经持有自旋锁时，其处于忙等待状态，则已经没有机会释放自己持有的锁了。如果这时再调用自身，则自旋锁永远没有执行的机会了。所以类似下面的递归形式是不能使用自旋锁的。</p>
</li>
<li><pre><code>void A()
{
    锁定自旋锁
    A();
    解锁自旋锁
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">**信号量**</span><br><span class="line"></span><br><span class="line">Linux中提供两种信号量，一种用于内核程序中，一种用于应用程序中。</span><br><span class="line"></span><br><span class="line">和自旋锁一样，也是保护临界资源的一种有用方法。信号量与自旋锁的使用方法基本一样。而信号量只有当得到信号量的进程或者线程时才能够进入临界区，执行临界代码。信号量与自旋锁的最大不同点在于，当一个进程试图去获取一个已经锁定的信号量时，进程不会像自旋锁一样在远处忙等待。</span><br><span class="line"></span><br><span class="line">当获取的信号量没有释放时，进程会将自身加入一个等待队列中去睡眠，知道拥有信号量的进程释放信号量后，处于等待队列中的那个进程才被唤醒。当进程唤醒后，就立刻重新从睡眠的地方开始执行，又一次试图获得信号量，当获得信号量后，程序继续执行。</span><br><span class="line"></span><br><span class="line">只有能够睡眠的进程才能够使用信号量，不能睡眠的进程不能使用信号量。例如中断需要立刻完成所以不能睡眠。</span><br><span class="line"></span><br><span class="line">**信号量的实现**</span><br><span class="line"></span><br><span class="line">定义</span><br></pre></td></tr></table></figure>
struct semaphore{
  spinlock_t lock;
  unsigned int  count;
  struct list_head  wait_list;
};
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**lock自旋锁**</span><br><span class="line"></span><br><span class="line">用来对count变量起保护作用。当count变化时，内部会锁定lock锁，但修改完成后会释放lock锁。</span><br><span class="line"></span><br><span class="line">**count变量**</span><br><span class="line"></span><br><span class="line">是信号量中一个非常重要的成员变量，这个变量可能取下面的3种值：</span><br><span class="line"></span><br><span class="line">* 等于0的值，如果这个值等于0，表示信号量被其他进程适合使用，现在不可以用这个信号量，但是wait_list队列中没有进程在等待信号量。</span><br><span class="line"></span><br><span class="line">* 小于0的值，表示至少有一个进程在wait_list队列中等待信号量被释放。</span><br><span class="line">* 大于0的值，表示这个信号量是空闲的，程序可以使用这个信号量。</span><br><span class="line"></span><br><span class="line">**定义和初始化**</span><br></pre></td></tr></table></figure>
struct semaphore sema;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">一个信号量必须初始化才能被使用，sema_init()函数用来初始化信号量，并设置sem中count的值为val，</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;c</span><br><span class="line">static inline void sema_init(struct semaphore *sem, int val)</span><br></pre></td></tr></table></figure>

另一个宏可以初始化一个信号量的值为1的信号量，这种信号量叫互斥体，
</code></pre></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> init_MUTEX(sem)   sema_init(sem,1)</span></span><br></pre></td></tr></table></figure>

<p>该宏用于初始化一个互斥的信号量，并将这个信号量sem的值设置为1，等同于sema_init(sem,1).另一个宏init_MUTEX_LOCKED也用来初始化一个信号量，其将信号量sem的值设置为0，定义为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define init_MUTEX_LOCKED(sem)    sema_init(sem, 0)</span><br></pre></td></tr></table></figure>

<p><strong>锁定信号量</strong></p>
<p>在进入临界区前，需要使用down()函数获得信号量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void down(struct semaphore *sem)</span><br></pre></td></tr></table></figure>

<p>该函数会导致睡眠，所以不能在中断上下文使用。另一个函数与down()函数相似，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int dow_interruptible(struct semaphore *sem)</span><br></pre></td></tr></table></figure>

<p>该函数与down()函数相似，不同之处在于，down函数进入睡眠之后，就不能够被信号唤醒，而down_interruptible()函数进入睡眠后可以被信号唤醒。如果被信号唤醒，那么会返回非0值。所以在调用down_interruptible()函数时，一般应该检查返回值，判断被唤醒的原因。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(down_interruptible(&amp;sem))&#123;</span><br><span class="line">	return -ERESTARTSYS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>释放信号量</strong></p>
<p>当不再使用临界区时，需要使用up()函数释放信号量，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void up(struct semaphore *sem)</span><br></pre></td></tr></table></figure>

<p><strong>使用信号量</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct semaphore sem;</span><br><span class="line">int xxx_init(void)&#123;</span><br><span class="line">	...</span><br><span class="line">	init_MUTEX()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a><strong>阻塞和非阻塞</strong></h2><p>阻塞调用是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后才会返回。有人也许会把阻塞调用和同步调用等同起来，实际上它们是不同的。对于同步调用来说，很多时候当前线程还是激活的，只有从逻辑上当前函数没有返回而已。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  
  
  

</article>
    
    <article id="post-基本的传感器" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/06/24/%E5%9F%BA%E6%9C%AC%E7%9A%84%E4%BC%A0%E6%84%9F%E5%99%A8/"
    >基本的传感器</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/06/24/%E5%9F%BA%E6%9C%AC%E7%9A%84%E4%BC%A0%E6%84%9F%E5%99%A8/" class="article-date">
  <time datetime="2020-06-24T05:16:42.000Z" itemprop="datePublished">2020-06-24</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h2 id="DY-SV5W"><a href="#DY-SV5W" class="headerlink" title="DY-SV5W"></a><strong>DY-SV5W</strong></h2><ul>
<li>完全支持FAT16/FAT32文件系统，最大支持32G的TF卡；</li>
<li>自带5W D类功放，可直接驱动4欧，3~5W喇叭</li>
<li>UART串口控制语音播放功能，可控制播放，暂停，选曲，音量加减等功能，最大选曲65535首曲目，波特率9600bit/s</li>
<li>支持IO触发播放，8个IO口单独触发8首曲目或者8个IO组合触发255首曲目。</li>
<li>支持3个配置IO进行多达7种工作模式选择，拨码开关设置简单。</li>
</ul>
<h3 id="外部引脚说明："><a href="#外部引脚说明：" class="headerlink" title="外部引脚说明："></a><strong>外部引脚说明：</strong></h3><table>
<thead>
<tr>
<th>引脚名称</th>
<th>引脚描述</th>
</tr>
</thead>
<tbody><tr>
<td>5V电源负极</td>
<td>接5V电源负极（GND）</td>
</tr>
<tr>
<td>5V电源正极</td>
<td>接5V电源正极</td>
</tr>
<tr>
<td>TXD/IO0</td>
<td>IO触发模式下为输入引脚IO0;UART控制模式下为TX引脚，连接控制端（MCU）的RX</td>
</tr>
<tr>
<td>RXD/IO1</td>
<td>IO触发模式下为输入引脚IO1;UART控制模式下为RX引脚，连接控制端（MCU）的TX</td>
</tr>
<tr>
<td>IO2</td>
<td>IO触发模式下为输入引脚IO2</td>
</tr>
<tr>
<td>IO3</td>
<td>IO触发模式下为输入引脚IO3</td>
</tr>
<tr>
<td>IO4</td>
<td>IO触发模式下为输入引脚IO4</td>
</tr>
<tr>
<td>IO5</td>
<td>IO触发模式下为输入引脚IO5</td>
</tr>
<tr>
<td>IO6</td>
<td>IO触发模式下为输入引脚IO6</td>
</tr>
<tr>
<td>IO7</td>
<td>IO触发模式下为输入引脚IO7</td>
</tr>
<tr>
<td>BUSY</td>
<td>播放曲目时输出低电压（0V），播放结束输出高电平（3.3V）</td>
</tr>
<tr>
<td>GND</td>
<td>参考地端（与控制端GND连接）</td>
</tr>
</tbody></table>
<h3 id="拨码开关模式配置："><a href="#拨码开关模式配置：" class="headerlink" title="拨码开关模式配置："></a><strong>拨码开关模式配置：</strong></h3><table>
<thead>
<tr>
<th>控制模式</th>
<th>配置引脚</th>
<th>I/O功能</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>CON3</td>
<td>CON2</td>
<td>CON1</td>
<td>IO7</td>
<td>IO6</td>
<td>IO5</td>
<td>IO4</td>
<td>IO3</td>
<td>IO2</td>
<td>IO1</td>
<td>IO0</td>
</tr>
<tr>
<td>I/O组合模式0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>按键组合播放，可播放2^8-1(255)首曲目</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>I/O组合模式1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>电平组合播放，可播放2^8-1(255)首曲目</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>I/O独立模式0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>曲目8</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>曲目1</td>
</tr>
<tr>
<td>I/O独立模式1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>曲目8</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>曲目1</td>
</tr>
<tr>
<td>UART串口模式</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>RXD</td>
<td>TXD</td>
</tr>
<tr>
<td>一线串口</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td>RXD</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>标准MP3模式</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td>RPT</td>
<td>EQ</td>
<td>P/P/MODE</td>
<td>PREV/V-</td>
<td>NEXT/V+</td>
</tr>
</tbody></table>
<blockquote>
<p>“按键组合播放”是指IO0-IO7输出对应的电平后恢复原来的高电平，类似于按键触发一次</p>
<p>“电平组合播放”是指IO0-IO7输出对应的电平后保持电平不变</p>
<p>“I/O组合（独立）模式0”与“I/O组合（独立）模式1”的区别在于前者释放电平后继续播放当前曲目至结束，后者模式释放电平后立即停止播放曲目。</p>
</blockquote>
<p>I/O组合模式0（按键组合播放）：</p>
<p>单片机控制I/0组合触发（低电平有效）指定的曲目后释放（IO0-IO7恢复高电平），播放完当前曲目停止；播放中途重新触发，播放新的曲目，播放结束停止后；若一直触发（不释放电平），循环播放；播放过程busy有效。</p>
<blockquote>
<p>曲目名称必须按照5位数字进行命名。</p>
</blockquote>
<table>
<thead>
<tr>
<th>IO7</th>
<th>IO6</th>
<th>IO5</th>
<th>IO4</th>
<th>IO3</th>
<th>IO2</th>
<th>IO1</th>
<th>IO0</th>
<th>播放曲目</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>00001.mp3</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>00002.mp3</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>00003.mp3</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>00004.mp3</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>00005.mp3</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>00006.mp3</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>00007.mp3</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>00255.mp3</td>
</tr>
</tbody></table>
<h3 id="IO组合模式1（电平组合播放）"><a href="#IO组合模式1（电平组合播放）" class="headerlink" title="IO组合模式1（电平组合播放）"></a><strong>IO组合模式1（电平组合播放）</strong></h3><p>单片机控制IO组合触发（低电平有效）指定的曲目，一直循环播放指定曲目，电平释放（IO0-IO7恢复高电平）即立即停止。播放中途释放电平，即刻停止播放。播放过程busy有效。</p>
<table>
<thead>
<tr>
<th>IO7</th>
<th>IO6</th>
<th>IO5</th>
<th>IO4</th>
<th>IO3</th>
<th>IO2</th>
<th>IO1</th>
<th>IO0</th>
<th>播放曲目</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>00001.mp3</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>00002.mp3</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>00003.mp3</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>00004.mp3</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>00005.mp3</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>00006.mp3</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>00007.mp3</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>00255.mp3</td>
</tr>
</tbody></table>
<p><strong>IO独立模式0（按键独立控制）</strong></p>
<p>IOO-IO7独立控制8首曲目，IO触发（低电平有效）指定的曲目后释放（IO0-IO7恢复高电平），播放完当前曲目停止；播放中途重新触发，播放新的曲目，播放结束停止；若一直触发不（不释放电平），循环播放；播放过程busy有效。</p>
<table>
<thead>
<tr>
<th>IO7</th>
<th>IO6</th>
<th>IO5</th>
<th>IO4</th>
<th>IO3</th>
<th>IO2</th>
<th>IO1</th>
<th>IO0</th>
<th>播放曲目</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>00001.mp3</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>00002.mp3</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>00003.mp3</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>00004.mp3</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>00005.mp3</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>00006.mp3</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>00007.mp3</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>00008.mp3</td>
</tr>
</tbody></table>
<h4 id="IO独立模式1（电平独立控制）"><a href="#IO独立模式1（电平独立控制）" class="headerlink" title="IO独立模式1（电平独立控制）"></a><strong>IO独立模式1（电平独立控制）</strong></h4><p>IO0-IO7独立控制8首曲目，IO触发（低电平有效）指定的曲目，一直循环播放指定曲目，电平释放（IO0-IO7恢复高电平）即停止播放。播放中途释放电平，即刻停止播放。播放过程busy有效。</p>
<h3 id="UART串口模式"><a href="#UART串口模式" class="headerlink" title="UART串口模式"></a><strong>UART串口模式</strong></h3><p>详见手册</p>
<h3 id="调试心得"><a href="#调试心得" class="headerlink" title="调试心得"></a>调试心得</h3><p>使用是按键组合模式，先将所有开关搬到数字位置，然后先测试下CPU板的8个引脚是否配置无误；还要有个BUSY引脚，该引脚上电初始化默认为1，无操作一直为1。</p>
<h2 id="STC8-EEPROM"><a href="#STC8-EEPROM" class="headerlink" title="STC8 EEPROM"></a><strong>STC8 EEPROM</strong></h2><p>STC8内部集成了大量的EEPROM，利用ISP/IAP技术可将内部Data Flash当EEPROM。</p>
<p>EEPROM可分为若干扇区，每个扇区包含512字节。使用时，建议同一次修改的数据放在同一个扇区，不是同一次修改的数据放在不同的扇区，不一定要用满。数据存储器的擦除操作是按扇区进行的。</p>
<p>EEPROM可用于保存一些需要在引用程序中修改并且掉电不丢失的数据。在用户程序中，可以对EEPROM进行字节读\字节编程\扇区擦除操作。在工作电压偏低时，建议不要进行EEPROM操作，以免发送数据丢失的情况。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>描述</th>
<th>地址</th>
<th>B7</th>
<th>B6</th>
<th>B5</th>
<th>B4</th>
<th>B3</th>
<th>B2</th>
<th>B1</th>
<th>B0</th>
<th>复位值</th>
</tr>
</thead>
<tbody><tr>
<td>IAP_DATA</td>
<td>IAP数据寄存器</td>
<td>C2H</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>1111,1111</td>
</tr>
<tr>
<td>IAP_ADDRH</td>
<td>IAP高地址寄存器</td>
<td>C3H</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0000,0000</td>
</tr>
<tr>
<td>IAP_ADDRL</td>
<td>IAP低地址寄存器</td>
<td>C4H</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0000,0000</td>
</tr>
<tr>
<td>IAP_CMD</td>
<td>IAP命令寄存器</td>
<td>C5H</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>CMD[1:0]</td>
<td>xxxx,xx00</td>
</tr>
<tr>
<td>IAP_TRIG</td>
<td>IAP触发寄存器</td>
<td>C6H</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0000,0000</td>
</tr>
<tr>
<td>IAP_CONTR</td>
<td>IAP控制寄存器</td>
<td>C7H</td>
<td>IAPEN</td>
<td>SWBS</td>
<td>SWRST</td>
<td>CMD_FAIL</td>
<td>-</td>
<td>IAP_WT[2:0]</td>
<td>IAP_WT[2:0]</td>
<td>IAP_WT[2:0]</td>
<td>0000,x000</td>
</tr>
</tbody></table>
<p><strong>EEPROM数据寄存器（IAP_DATA）</strong></p>
<p>在进行EEPROM的读操作时，命令执行完成后读出的EEPROM数据保存在IAP_DATA寄存器中。在进行EEPROM的写操作时，在执行写命令前，必须将待写入的数据存在IAP_DATA寄存器中，再发送写命令。擦除EEPROM命令与IAP_DATA寄存器无关。</p>
<p><strong>IAP_ADDRH</strong></p>
<p><strong>IAP_ADDRL</strong></p>
<p>EEPROM进行读、写、擦除操作的目标地址寄存器。IAP_ADDRH保存地址的高字节，IAP_ADDRL保存地址的低字节。</p>
<p><strong>IAP_CMD</strong></p>
<p>命令寄存器，发送操作命令</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>地址</th>
<th>B7</th>
<th>B6</th>
<th>B5</th>
<th>B4</th>
<th>B3</th>
<th>B2</th>
<th>B1</th>
<th>B0</th>
</tr>
</thead>
<tbody><tr>
<td>IAP_CMD</td>
<td>C5H</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>CMD[1]</td>
<td>CMD[0]</td>
</tr>
</tbody></table>
<p>CMD[1:0]:</p>
<p>00:空操作</p>
<p>01：读EEPROM命令，读取目标地址所在的1字节</p>
<p>10：写EEPROM命令，写目标地址所在的1字节。</p>
<p>11：擦除EEPROM,擦除目标地址所在的1页（1扇区/512字节）</p>
<p>EEPROM触发寄存器</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>地址</th>
<th>B7</th>
<th>B6</th>
<th>B5</th>
<th>B4</th>
<th>B3</th>
<th>B2</th>
<th>B1</th>
<th>B0</th>
</tr>
</thead>
<tbody><tr>
<td>IAP_TRIG</td>
<td>C6H</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>每次EEPROM操作时，都要对IAP_TRIG先写入5AH，再写入A5H,相应的命令才会生效。写完触发命令后，CPU会处于IDLE等待状态，直到相应的IAP操作执行完成后CPU才会从IDLE状态返回正常状态继续执行CPU指令。</p>
<p>IAP_CONTR EEPROM控制寄存器</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>地址</th>
<th>B7</th>
<th>B6</th>
<th>B5</th>
<th>B4</th>
<th>B3</th>
<th>B2</th>
<th>B1</th>
<th>B0</th>
</tr>
</thead>
<tbody><tr>
<td>IAP_CONTR</td>
<td>C7H</td>
<td>IAPEN</td>
<td>SWBS</td>
<td>SWRST</td>
<td>CMD_FAIL</td>
<td>-</td>
<td>IAP_WT[2:0]</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>IAPEN:EEPROM操作使能控制位       0：禁止EEPROM操作，  1 ： 使能EEPROM操作</p>
<p>SWBS: 软件复位选择控制位（配合SWRST使用）   0 ： 软件复位后从用户代码开始执行程序  1：软件复位后从系统ISP监控代码区开始执行程序</p>
<p>SWRST:软件复位控制位</p>
<p>0：无动作</p>
<p>1：产生软件复位</p>
<p>CMD_FAIL ： EEPROM操作失败状态位，需要软件清零</p>
<p>0：EEPROM操作正确</p>
<p>1：EEPROM操作失败</p>
<p>IAP_WT[2:0]: 设置EEPROM操作的等待时间。</p>
<p>EEPROM总是从后向前进行规划的。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  
  
  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2020
        <i class="ri-heart-fill heart_icon"></i> Chen Bin
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="梦想岛"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">算法与程序设计</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E4%BB%A3%E7%A0%81%E8%AF%B4/">代码说</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="http://chenbin-vip.lofter.com" target="_blank" rel="noopener">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E5%A4%96%E8%AF%AD%E5%AD%A6%E4%B9%A0/">外语学习</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84/">法律法规</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/about/">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://i.loli.net/2020/04/24/VjamHOiTgk26EpK.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://i.loli.net/2020/04/24/FMJN75HGXRpDdP4.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Subtitle -->

<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
      startDelay: 0,
      typeSpeed: 180,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
    console.log(err)
  }
</script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>

<!-- Katex -->


    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css">
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"></script>
        
    


<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->


<script src="/js/clickLove.js"></script>


<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>



    
  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

</html>